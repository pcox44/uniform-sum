<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Uniform Sum Simulation</title>

<style>

/* Target input styling */
#targetSumInput {
  width: 80px;           /* make it wider */
  text-align: center;    /* center the number */
  font-size: 20px;       /* optional: make the number bigger */
  padding: 6px 10px;     /* slightly bigger padding */
  border-radius: 8px;
  border: 2px solid #26a69a;
  background: rgba(10,10,30,0.9);
  color: #fff;
  outline: none;
  box-shadow: inset 0 0 6px rgba(0,255,255,0.2);
}


#topDesc {
  padding: 10px 16px;
  background: rgba(20,20,40,0.9);
  border-radius: 10px;
  line-height: 1.5;
  margin-bottom: 24px; /* increase spacing below */
}

#targetLabel {
  font-size: 36px;  /* make it bigger */
  font-weight: bold;
  color: #b3e5fc;
  text-shadow: 0 0 8px rgba(0,255,255,0.8);
}


#controls label[for="targetSumInput"] {
  font-size: 36px;   /* bigger */
  font-weight: bold;
}


#targetSumInput:focus {
  border-color: #00e5ff;
  box-shadow: 0 0 12px rgba(0,255,255,0.7), inset 0 0 8px rgba(0,255,255,0.3);
}


* { box-sizing: border-box; margin: 0; padding: 0; }

/* Histogram table styling */
#histTableContainer table {
  width: 100%;
  border-collapse: collapse;
  font-size: 16px;
  table-layout: auto;
}

#histTableContainer th, #histTableContainer td {
  border: 1px solid rgba(255,255,255,0.3);
  padding: 10px 14px;
  text-align: center;
}

#histTableContainer th {
  background: rgba(20, 60, 100, 0.8);
  color: #b3e5fc;
  font-weight: bold;
}

body {
  font-family: 'Segoe UI', sans-serif;
  background: radial-gradient(circle at top left, #1a237e 0%, #311b92 100%);
  color: #eee;
  padding: 20px;
}

/* Force a wide content area to preserve 2-column layout and canvases */
body {
  overflow-x: auto;   /* horizontal scroll if needed */
  overflow-y: auto;
  min-width: 1000px;  /* adjust as needed to fit your canvases & columns */
}

/* Ensure container preserves layout */
.container {
  min-width: 1000px;  /* match or slightly less than body min-width */
}

/* Canvases scale within desktop but maintain minimum width */
#stickCanvas, #histCanvas {
  min-width: 800px;   /* ensures the canvas doesn’t shrink too small */
  max-width: 100%;
}


h1 { 
  text-align: center;
  font-size: clamp(28px,5vw,48px);
  color: #fff;
  text-shadow: 2px 2px 6px rgba(0,0,0,0.8);
  margin-bottom: 20px;
}

.container {
  display: flex;
  flex-wrap: nowrap; /* stay side by side */
  gap: 20px;
  max-width: 1600px;
  margin: 0 auto;
}

.left-panel { 
  flex: 2 1 65%; /* larger column */
  min-width: 300px; 
}

.right-panel { 
  flex: 1 1 30%; /* smaller column */
  display: flex; 
  flex-direction: column; 
  gap: 20px; 
}


canvas {
  width: 100%;
  display: block;
  border-radius: 10px;
  margin-bottom: 12px;
}

#stickCanvas { height: 120px; background: rgba(20,20,40,0.9); box-shadow: 0 8px 20px rgba(0,0,0,0.35); }
#histCanvas { height: 300px; background: rgba(30,30,50,0.9); }

#controls {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  align-items: center;
  background: rgba(25,25,60,0.85);
  padding: 12px;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
  margin-bottom: 12px;
}

/* Buttons styling */
button { 
  margin: 8px 6px 8px 0; 
  padding: 14px 28px;       /* bigger padding */
  font-size: 16px;          /* slightly larger text */
  border: none; 
  border-radius: 10px; 
  cursor: pointer; 
  background: linear-gradient(135deg,#26a69a,#004d40); 
  color:white; 
  transition: all 0.2s ease;
  min-width: 120px;          /* ensure wider clickable area */
}

button:hover { 
  background: linear-gradient(135deg,#4db6ac,#00695c); 
  box-shadow: 0 0 12px rgba(0,255,255,0.5);
  transform: scale(1.05);
}

label {
  color: #b3e5fc;
  font-weight: bold;
  font-size: 16px;
}

input[type="number"] {
  width: 60px;
  padding: 6px;
  font-size: 16px;
  border-radius: 6px;
  border: 2px solid #26a69a;
  background: rgba(10,10,30,0.9);
  color: #fff;
  text-align: center;
  outline: none;
}
input[type="number"]:focus { border-color: #00e5ff; box-shadow: 0 0 8px #00e5ff; }

#stats, #lastTrialBox, #histTableContainer, .collapsible-content {
  padding: 12px;
  background: rgba(30,30,60,0.95);
  border-radius: 10px;
  margin-bottom: 12px;
  font-size: 24px;
}

.stickSpan { display:inline-block; margin:2px 4px; padding:2px 4px; border-radius:3px; }

.collapsible {
  background: rgba(30,30,60,0.95);
  color: #fff;
  cursor: pointer;
  padding: 10px;
  border-radius: 10px;
  font-size: 16px;
  margin-bottom: 6px;
  width: 20%;
  text-align: left;
  border: none;
}
.collapsible:after { content: '\25BC'; float:right; }
.collapsible.active:after { content: '\25B2'; }
.collapsible-content { display:none; }

@media (max-width: 768px) {
  button { font-size: 12px; padding: 6px 10px; }
  label { font-size: 14px; }
  #stickCanvas { height: 90px; }
  #histCanvas { height: 160px; }
}

@media (max-width: 768px) {
  #stickCanvas,
  #histBox,
  #histTableContainer {
    display: none;
  }
}


@media (max-width: 768px) {
  body {
    min-width: 800px;  /* ensures the content can scroll horizontally */
  }
}



</style>
</head>

<body>

<h1>Uniform Sum Simulation</h1>

<div id="topDesc">
  <strong>Process:</strong> Select uniform random numbers [0–1]. Lay sticks end-to-end until they exceed the target. Count how many sticks were needed.
</div>

<canvas id="stickCanvas"></canvas>

<div class="container">
  <div class="left-panel">
    <div id="controls">
      <button id="dropStick">Drop 1 Stick</button>
      <button id="dropOneTrial">Run 1 Trial</button>
      <button id="drop10">Run 10</button>
      <button id="drop1000">Run 1000</button>
      <button id="resetHist">Reset</button>
      <label for="targetSumInput">Target:</label>
      <input type="number" id="targetSumInput" value="1" step="0.01" min="0.01">
    </div>

    <canvas id="histCanvas"></canvas>
    <div id="histTableContainer"></div>
  </div>

  <div class="right-panel">
    <div id="stats"></div>
    <div id="lastTrialBox"></div>
  </div>
</div>

<button class="collapsible">Explanation</button>
<div class="collapsible-content">
  <p>Pick independent random numbers X₁, X₂, … from 0 to 1. Let N be the smallest number so that X₁ + … + X<sub>N</sub> exceeds the target. For target=1, P(N=n)=1/n!. So expected numbers needed ≈ e.</p>
  <p><strong>Simplex Explanation:</strong> The n-dimensional simplex X₁+…+X<sub>n</sub>≤1 with Xᵢ≥0 has volume 1/n!, matching probability that nth stick exceeds the target.</p>
</div>

<script>
// Collapsible
document.querySelectorAll(".collapsible").forEach(btn=>{
  btn.addEventListener("click",function(){
    this.classList.toggle("active");
    const content=this.nextElementSibling;
    content.style.display=(content.style.display==='block')?'none':'block';
  });
});

// Core variables
const stickCanvas = document.getElementById('stickCanvas');
const ctx = stickCanvas.getContext('2d');
const histCanvas = document.getElementById('histCanvas');
const histCtx = histCanvas.getContext('2d');
const statsDiv = document.getElementById('stats');
const lastTrialBox = document.getElementById('lastTrialBox');

let targetSum = parseFloat(document.getElementById('targetSumInput').value);
let currentSticks = [], currentSum = 0;
let trialResults = [], lastStickIndices = [];
let dropOneActive = false;

const colors = ['#ff9800','#00ff00','#ff00ff','#ff1744','#00FFFF','#B57EDC','#ffeb3b','#FF8DA1','#0096FF'];

function getStickColor(i){ return colors[i%colors.length]; }

function drawBase() { 
  ctx.clearRect(0, 0, stickCanvas.width, stickCanvas.height);

  const baseY = stickCanvas.height - 50;
  const overflowFraction = 0.10; // extra width beyond target
  const maxSum = targetSum * (1 + overflowFraction);
  const scale = stickCanvas.width / maxSum;

  // Draw base line
  ctx.strokeStyle = "#aaa";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(0, baseY);
  ctx.lineTo(stickCanvas.width, baseY);
  ctx.stroke();

  // Draw checkerboard in overflow region
  const checkerStartX = targetSum * scale;
  const checkerEndX = stickCanvas.width;
  const checkerHeight = stickCanvas.height;
  const boxSize = 8;

  for (let y = 0; y < checkerHeight; y += boxSize) {
    let toggle = Math.floor(y / boxSize) % 2 === 0;
    for (let x = checkerStartX; x < checkerEndX; x += boxSize) {
      ctx.fillStyle = toggle ? "#fff" : "#000";
      ctx.fillRect(x, y, boxSize, boxSize);
      toggle = !toggle;
    }
  }

  return baseY;
}


function drawStickSegment(x, width, y, index, val, isLast=false) {
  const stickHeight = stickCanvas.height * 0.50;
  const color = getStickColor(index);

  // Draw stick
  ctx.fillStyle = color;
  ctx.fillRect(x, y, width, stickHeight);

  ctx.lineWidth = 6;
  ctx.strokeStyle = 'black';
  ctx.strokeRect(x, y, width, stickHeight);

  // Text size
  let fontSize = (val < 0.02) ? 10 : Math.min(24, Math.max(14, stickHeight * 0.6));
  ctx.font = `bold ${fontSize}px Segoe UI`;
  ctx.textBaseline = 'middle';
  ctx.fillStyle = '#000';

  const cy = y + stickHeight / 2;

  // Default: center
  let textX = x + width / 2;
  ctx.textAlign = 'center';

  if (isLast) {
    const canvasRight = stickCanvas.width;
    const stickEnd = x + width;
    const visibleWidth = Math.min(width, canvasRight - x); // how much is visible

    // proportional offset: if fully visible, center; if partially off, shift left proportionally
    const fractionVisible = visibleWidth / width;
    textX = x + width * Math.min(fractionVisible, 0.9) / 2; // don't go all the way left
    ctx.textAlign = 'center';
  }

  ctx.fillText(val.toFixed(2), textX, cy);
}

async function dropStickAnimated(len,index){
  const baseY = drawBase();
  const scale = stickCanvas.width/(targetSum*1.1);
  const stickWidth = len*scale;
  const x=currentSticks.slice(0,index).reduce((a,b)=>a+b,0)*scale;
  let y=-60;
  return new Promise(resolve=>{
    function fall(){
      drawBase();
      let px=0;
      for(let i=0;i<index;i++){
        drawStickSegment(px,currentSticks[i]*scale,baseY-28,i,currentSticks[i],false);
        px+=currentSticks[i]*scale;
      }
      if(y<baseY-28){ y+=7; drawStickSegment(px,stickWidth,y,index,len,false); requestAnimationFrame(fall);}
      else { drawStickSegment(px,stickWidth,baseY-28,index,len,true); resolve();}
    }
    fall();
  });
}

function resetTrialState(){ currentSticks=[]; currentSum=0; drawBase(); dropOneActive=false; }
function endTrial(){ trialResults.push(currentSticks.length); lastStickIndices.push(currentSticks.length-1); dropOneActive=false; updateHistogram(); updateStats(); updateLastTrialBox(); }

function updateLastTrialBox(){
  if(currentSticks.length===0){ lastTrialBox.innerHTML='No trial yet.'; return; }
  let sum=0; let content='';
  currentSticks.forEach((v,i)=>{
    sum+=v; const isLast=sum>targetSum;
    const color=getStickColor(i);
    content+=`<span class="stickSpan" style="color:${color};${isLast?`border:2px solid ${color};`:''}">${v.toFixed(3)}</span> `;
  });
  lastTrialBox.innerHTML=`<strong>Last trial:</strong><br>${content}<br>
    <strong>Sum:</strong> ${sum.toFixed(3)} > ${targetSum}
    <span style="margin-left:20px;"><strong>Sticks used:</strong> ${currentSticks.length}</span>`;
}

function updateStats(){
  if(trialResults.length===0){ statsDiv.innerHTML=''; return; }
  const n = trialResults.length;
  const avg = trialResults.reduce((a,b)=>a+b,0)/n;
  let html=`<strong>Trials:</strong> ${n}<br><strong>Average sticks:</strong> ${avg.toFixed(4)}<br>`;
  if(targetSum===1){ html+=`<strong>Theoretical:</strong> e ≈ ${Math.E.toFixed(4)}<br><strong>|Sim - Theo|:</strong> ${(Math.abs(avg-Math.E)).toFixed(4)}`; }
  else if(targetSum===2){ html+=`<strong>Theoretical:</strong> e²-e ≈ ${(Math.E**2-Math.E).toFixed(4)}<br><strong>|Sim - Theo|:</strong> ${(Math.abs(avg-(Math.E**2-Math.E))).toFixed(4)}`; }
  statsDiv.innerHTML=html;
}

// --- Histogram Table ---
function updateHistTable() {
  const container = document.getElementById("histTableContainer");

  if (trialResults.length === 0) {
    container.innerHTML = "";
    return;
  }

  const maxVal = Math.max(...trialResults);
  const labels = Array.from({length: maxVal}, (_, i) => i + 1);
  const total = trialResults.length;

  let runningSum = 0;

  let html = `<table style="width:100%; border-collapse: collapse; text-align:center;">
      <tr>
        <th style="border:1px solid #fff; padding:6px;">Sticks</th>
        <th style="border:1px solid #fff; padding:6px;">Count</th>
        <th style="border:1px solid #fff; padding:6px;">Rel. Freq</th>
        <th style="border:1px solid #fff; padding:6px;">Running Sum</th>
      </tr>`;

  labels.forEach(l => {
    const count = trialResults.filter(v => v === l).length;

    // Skip rows with 0 count if targetSum > 4
    if (targetSum > 4 && count === 0) return;

    const rel = count / total;
    const contribution = l * rel;
    runningSum += contribution;

    html += `
      <tr>
        <td style="border:1px solid #fff; padding:6px;">${l}</td>
        <td style="border:1px solid #fff; padding:6px;">${count}</td>
        <td style="border:1px solid #fff; padding:6px;">${rel.toFixed(4)}</td>
        <td style="border:1px solid #fff; padding:6px;">${runningSum.toFixed(4)}</td>
      </tr>`;
  });

  html += `</table>`;
  container.innerHTML = html;
}

// --- Histogram Drawing ---
function updateHistogram() {
  histCtx.clearRect(0,0,histCanvas.width,histCanvas.height);

  const topPadding = 40;
  const bottomPadding = 60;
  const leftPadding = 70;
  const rightPadding = 20;

  const plotWidth = histCanvas.width - leftPadding - rightPadding;
  const plotHeight = histCanvas.height - topPadding - bottomPadding;

  if(trialResults.length===0) {
    updateHistTable();
    return;
  }

  let labels, maxVal;

  if(targetSum > 4){
    // Only show results actually observed
    const observed = trialResults.filter(v => v > 0);
    const minObserved = Math.min(...observed);
    const maxObserved = Math.max(...observed);

    const start = Math.max(1, minObserved - 3); // 3 less than lowest
    labels = [];
    for(let l = start; l <= maxObserved; l++){
      if(trialResults.includes(l)) labels.push(l);
    }
    maxVal = Math.max(...labels);
  } else {
    maxVal = Math.max(...trialResults, 10);
    labels = Array.from({length:maxVal},(_,i)=>i+1);
  }

  const counts = labels.map(l => trialResults.filter(v => v === l).length);
  const proportions = counts.map(c => c / trialResults.length);
  const maxProp = Math.max(...proportions);
  const yMax = maxProp * 1.1;

  const barWidth = plotWidth / labels.length * 0.8;

  // Draw horizontal grid lines
  histCtx.strokeStyle = 'rgba(255,255,255,0.2)';
  histCtx.lineWidth = 1;
  histCtx.font = '14px Segoe UI';
  histCtx.fillStyle = '#fff';
  histCtx.textAlign = 'right';
  histCtx.textBaseline = 'middle';

  const ySteps = 5;
  for(let i = 0; i <= ySteps; i++) {
      const prop = (i / ySteps) * maxProp;
      const yPos = topPadding + plotHeight - (prop / yMax * plotHeight);

      histCtx.beginPath();
      histCtx.moveTo(leftPadding, yPos);
      histCtx.lineTo(histCanvas.width - rightPadding, yPos);
      histCtx.stroke();

      histCtx.fillText(prop.toFixed(2), leftPadding - 10, yPos);
  }

  // Y-axis label
  histCtx.save();
  histCtx.translate(20, histCanvas.height / 2);
  histCtx.rotate(-Math.PI / 2);
  histCtx.textAlign = 'center';
  histCtx.textBaseline = 'middle';
  histCtx.fillStyle = '#fff';
  histCtx.font = '16px Segoe UI';
  histCtx.fillText('Proportion', 0, 0);
  histCtx.restore();

  // Draw bars
  labels.forEach((label,i)=>{
    const count = counts[i];
    const proportion = proportions[i];
    const h = proportion / yMax * plotHeight;
    const color = getStickColor(label-1);
    histCtx.fillStyle = color;
    histCtx.fillRect(leftPadding + i*(plotWidth/labels.length)+barWidth*0.1,
                     topPadding + plotHeight - h,
                     barWidth,
                     h);
    histCtx.fillStyle = '#fff';
    histCtx.textAlign = 'center';
    histCtx.textBaseline = 'top';
    histCtx.fillText(label, leftPadding + i*(plotWidth/labels.length)+barWidth/2, topPadding + plotHeight + 5);
  });

  // X-axis label
  histCtx.textAlign = 'center';
  histCtx.textBaseline = 'top';
  histCtx.fillText('Sticks Needed', leftPadding + plotWidth/2, histCanvas.height - bottomPadding + 20);

  updateHistTable();
}

// --- Button events ---
document.getElementById('dropStick').onclick=async()=>{
  if(!dropOneActive) resetTrialState(), dropOneActive=true;
  const len=Math.random(); currentSticks.push(len); currentSum+=len;
  await dropStickAnimated(len,currentSticks.length-1);
  if(currentSum>targetSum) endTrial();
};
document.getElementById('dropOneTrial').onclick=async()=>{
  resetTrialState();
  let s=0;
  while(s<=targetSum){ const len=Math.random(); currentSticks.push(len); await dropStickAnimated(len,currentSticks.length-1); s+=len; currentSum=s; }
  endTrial();
};
document.getElementById('drop10').onclick=()=>runTrials(10,false);
document.getElementById('drop1000').onclick=()=>runTrials(1000,false);
document.getElementById('resetHist').onclick=()=>{ trialResults=[]; updateHistogram(); resetTrialState(); };
document.getElementById('targetSumInput').addEventListener('input',e=>{ targetSum=parseFloat(e.target.value); trialResults=[]; updateHistogram(); resetTrialState(); });

function runTrials(n,reset=true){ if(reset) resetTrialState();
  for(let t=0;t<n;t++){ let s=0,count=0; while(s<=targetSum){ s+=Math.random(); count++; } trialResults.push(count); lastStickIndices.push(count-1); }
  updateHistogram(); updateStats(); if(reset) resetTrialState();
}

// --- Canvas DPI fix ---
function fixCanvasDPI(canvas,ctx){
  const dpr=window.devicePixelRatio||1;
  const rect=canvas.getBoundingClientRect();
  canvas.width=rect.width*dpr;
  canvas.height=rect.height*dpr;
  ctx.scale(dpr,dpr);
}
fixCanvasDPI(stickCanvas,ctx); fixCanvasDPI(histCanvas,histCtx);
drawBase(); updateHistogram();

window.addEventListener('resize',()=>{ fixCanvasDPI(stickCanvas,ctx); fixCanvasDPI(histCanvas,histCtx); drawBase(); updateHistogram(); });


</script>

</body>
</html>

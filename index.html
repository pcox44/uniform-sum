<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Uniform Sum Simulation for e</title>
<style>
body {
  font-family: 'Segoe UI', sans-serif;
  background: radial-gradient(circle at top left, #1a237e 0%, #311b92 100%);
  color: #eee;
  text-align: center;
  margin: 0;
  padding: 10px;
}
h1 { margin: 12px; color: #fff; text-shadow: 2px 2px 6px rgba(0,0,0,0.8);}
#topDesc, #explanation {
  max-width: 1000px;
  margin: 10px auto;
  padding: 10px 16px;
  background: rgba(20,20,40,0.9);
  border-radius: 10px;
  text-align: left;
  line-height: 1.5;
}
#controls { margin: 12px auto; }
button { margin: 5px; padding: 10px 20px; font-size: 15px; border: none; border-radius: 8px; cursor: pointer; background: linear-gradient(135deg,#26a69a,#004d40); color:white; }
button:hover { background: linear-gradient(135deg,#4db6ac,#00695c); transform: scale(1.05);}
label { margin-left: 10px; font-weight: bold; }
canvas { display: block; margin: 12px auto; background: rgba(20,20,40,0.9); border-radius: 10px; box-shadow: 0 8px 20px rgba(0,0,0,0.35);}
#stickCanvas { width: min(95vw,1000px); height: 220px; }
#chartCanvas { width: min(95vw,1000px); height: 280px; }
#histCanvas { width: min(95vw,1000px); height: 240px; }
#stats { margin-top:10px; padding: 12px 16px; background: rgba(40,40,60,0.9); border-radius: 10px; text-align: left; min-width: 320px; color: #fff; }
</style>
</head>
<body>

<h1>Uniform Sum Simulation for e</h1>

<div id="topDesc">
<strong>Process:</strong> Pick numbers of random length (0–1) end-to-end until they exceed the target (1 or 2). Count how many sticks were needed.
</div>

<div id="controls">
  <button id="dropStick">Drop One Stick</button>
  <button id="dropOneTrial">Run 1 Trial</button>
  <button id="drop10">Run 10</button>
  <button id="drop100">Run 100</button>
  <button id="drop1000">Run 1000</button>
  <label for="targetSum">Target sum:</label>
  <select id="targetSum">
    <option value="1" selected>1 (≈ e)</option>
    <option value="2">2 (≈ e² − e)</option>
  </select>
</div>

<canvas id="stickCanvas" width="1000" height="220"></canvas>
<canvas id="chartCanvas" width="1000" height="280"></canvas>
<canvas id="histCanvas" width="1000" height="240"></canvas>
<div id="stats"></div>

<div id="explanation">
<strong>Why it’s e:</strong> If X₁, X₂, … are Uniform(0,1) and N is the smallest integer s.t. X₁+…+X_N > target, E[N]=e for target=1, and e²−e for target=2. This simulation shows the convergence empirically.
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
const stickCanvas = document.getElementById('stickCanvas');
const ctx = stickCanvas.getContext('2d');
const chartCanvas = document.getElementById('chartCanvas');
const histCanvas = document.getElementById('histCanvas');
const statsDiv = document.getElementById('stats');

let targetSum = parseFloat(document.getElementById('targetSum').value);
let currentSticks = [], currentSum = 0;
let trialColors = [], trialResults = [], runningAverages = [];
let animating = false;

function makeColors(n=1000){
  let arr=[];
  for(let i=0;i<n;i++){arr.push(`hsl(${(i*137.5)%360},60%,60%)`);}
  return arr;
}
trialColors = makeColors();

function drawBase(){ const baseY=stickCanvas.height-40; ctx.strokeStyle="#aaa"; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(0,baseY); ctx.lineTo(stickCanvas.width,baseY); ctx.stroke(); return baseY; }

function drawStickSegment(x,width,y,index,val,isLast=false){
  const color = trialColors[index%trialColors.length];
  ctx.fillStyle=color; ctx.shadowColor=color; ctx.shadowBlur=12;
  ctx.fillRect(x,y,Math.max(2,width),28); ctx.shadowBlur=0;

  ctx.font='bold 14px Segoe UI'; ctx.textBaseline='middle';
  ctx.strokeStyle='rgba(0,0,0,0.8)'; ctx.lineWidth=4;

  // Place label left if this stick pushes sum over target
  ctx.textAlign = isLast ? 'left' : 'center';
  const cx = isLast ? x+2 : x+width/2;
  const cy = y+14;
  ctx.strokeText(val.toFixed(2), cx, cy); ctx.fillStyle='#fff';
  ctx.fillText(val.toFixed(2), cx, cy);
}

async function dropStickAnimated(len,index){
  const baseY=drawBase(), scale=stickCanvas.width/targetSum, stickWidth=len*scale;
  const x=currentSticks.slice(0,index).reduce((a,b)=>a+b,0)*scale;
  let y=-60;
  const isLast = currentSticks.reduce((a,b)=>a+b,0) + len > targetSum; // last stick over target
  return new Promise(resolve=>{
    function fall(){
      ctx.clearRect(0,0,stickCanvas.width,baseY);
      drawBase();
      let px=0;
      for(let i=0;i<index;i++){drawStickSegment(px,currentSticks[i]*scale,baseY-28,i,currentSticks[i]); px+=currentSticks[i]*scale;}
      if(y<baseY-28){ y+=20; drawStickSegment(x,stickWidth,y,index,len,isLast); requestAnimationFrame(fall); }
      else { drawStickSegment(x,stickWidth,baseY-28,index,len,isLast); resolve(); }
    } fall();
  });
}

function resetTrialState(){ currentSticks=[]; currentSum=0; drawBase(); }

function endTrial(){ trialResults.push(currentSticks.length); let sum=0; runningAverages=trialResults.map((v,i)=>{sum+=v;return sum/(i+1);}); updateCharts(); updateStats(); }

function updateCharts(){
  const ref=(targetSum===1)?Math.E:(Math.E**2-Math.E);
  lineChart.data.labels=trialResults.map((_,i)=>i+1);
  lineChart.data.datasets[0].data=runningAverages.slice();
  lineChart.data.datasets[1].data=Array(trialResults.length).fill(ref);
  lineChart.options.scales.y.min=Math.max(0,ref-1.2); lineChart.options.scales.y.max=ref+1.2;
  lineChart.update();

  const freq={};
  for(const v of trialResults) freq[v]=(freq[v]||0)+1;
  const keys=Object.keys(freq).map(Number).sort((a,b)=>a-b);
  histChart.data.labels=keys;
  histChart.data.datasets[0].data=keys.map(k=>freq[k]);
  // Match histogram color to stick color
  histChart.data.datasets[0].backgroundColor=keys.map(k=>trialColors[(k-1)%trialColors.length]);
  histChart.update();
}

function updateStats(){
  if(trialResults.length===0){statsDiv.innerHTML=''; return;}
  const n=trialResults.length;
  const avg=runningAverages[runningAverages.length-1];
  const variance=trialResults.reduce((a,b)=>a+Math.pow(b-avg,2),0)/n;
  const std=Math.sqrt(variance);
  const ref=(targetSum===1)?Math.E:(Math.E**2-Math.E);
  statsDiv.innerHTML=`<strong>Trials:</strong>${n}<br><strong>Average sticks/trial:</strong>${avg.toFixed(4)}<br><strong>Std deviation:</strong>${std.toFixed(4)}<br><strong>Theoretical:</strong>${ref.toFixed(4)}`;
}

async function runSingleTrial(){
  if(animating) return; animating=true; resetTrialState();
  let s=0;
  while(s<=targetSum){ const len=Math.random(); currentSticks.push(len); await dropStickAnimated(len,currentSticks.length-1); s+=len; currentSum=s; }
  endTrial(); animating=false;
}

function runTrials(n){
  const newResults=[];
  for(let i=0;i<n;i++){let s=0,count=0; while(s<=targetSum){s+=Math.random(); count++;} newResults.push(count);}
  trialResults.push(...newResults); let sum=0; runningAverages=trialResults.map((v,i)=>{sum+=v; return sum/(i+1);}); updateCharts(); updateStats();
}

// Chart.js
const lineChart=new Chart(chartCanvas,{type:'line',data:{labels:[],datasets:[{label:'Trial Average',data:[],borderColor:'#00e5ff',borderWidth:3,tension:0.25,fill:false},{label:'Expected Value',data:[],borderColor:'#ff4081',borderDash:[6,6],borderWidth:2,fill:false}]},options:{animation:{duration:300},scales:{y:{ticks:{color:'#fff'}},x:{ticks:{color:'#fff'}}},plugins:{legend:{labels:{color:'#fff'}}}}});
const histChart = new Chart(histCanvas, {
  type: 'bar',
  data: { labels: [], datasets: [{ label: 'Stick Count Frequency', data: [], backgroundColor: [] }] },
  options: {
    responsive: true,
    scales: {
      y: { beginAtZero: true, ticks: { color: '#fff' } },
      x: { ticks: { color: '#fff' } }
    },
    plugins: { legend: { labels: { color: '#fff' } } }
  }
});

// --- Button Actions ---
document.getElementById('dropStick').onclick = async () => {
  if (animating) return;

  // If we have already completed a trial, reset for a new one
  if (currentSum >= targetSum) {
    currentSticks = [];
    currentSum = 0;
    drawBase();
  }

  animating = true;
  const len = Math.random();
  currentSticks.push(len);
  currentSum += len;

  await dropStickAnimated(len, currentSticks.length - 1);

  animating = false;

  // Only end the trial if sum exceeds target
  if (currentSum > targetSum) {
    endTrial();
  }
};


document.getElementById('dropOneTrial').onclick = runSingleTrial;
document.getElementById('drop10').onclick = ()=>runTrials(10);
document.getElementById('drop100').onclick = ()=>runTrials(100);
document.getElementById('drop1000').onclick = ()=>runTrials(1000);

document.getElementById('targetSum').onchange = (e) => {
  targetSum = parseFloat(e.target.value);
  resetTrialState();
  trialResults=[];
  runningAverages=[];
  updateCharts();
  updateStats();
};

// Initialize
resetTrialState();
updateCharts();
updateStats();
</script>
</body>
</html>

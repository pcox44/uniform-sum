<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Uniform Sum Simulation for e</title>
<style>
body {
  font-family: 'Segoe UI', sans-serif;
  background: radial-gradient(circle at top left, #1a237e 0%, #311b92 100%);
  color: #eee;
  margin: 0;
  padding: 10px;
  overflow-x: hidden;
}
h1 { margin: 12px; color: #fff; text-shadow: 2px 2px 6px rgba(0,0,0,0.8);}
#topDesc, #explanation {
  max-width: 1000px;
  margin: 10px auto;
  padding: 10px 16px;
  background: rgba(20,20,40,0.9);
  border-radius: 10px;
  text-align: left;
  line-height: 1.5;
}
#controls { margin: 12px auto; text-align: center; }
button { margin: 5px; padding: 10px 20px; font-size: 15px; border: none; border-radius: 8px; cursor: pointer; background: linear-gradient(135deg,#26a69a,#004d40); color:white; }
button:hover { background: linear-gradient(135deg,#4db6ac,#00695c); transform: scale(1.05);}
label { margin-left: 10px; font-weight: bold; }
canvas { display: block; margin: 12px auto; border-radius: 10px; box-shadow: 0 8px 20px rgba(0,0,0,0.35);}
#stickCanvas { width: min(95vw,1000px); height: 220px; background: rgba(20,20,40,0.9);}
#histBox { width: min(95vw,1000px); margin: 0 auto; background: rgba(20,20,40,0.9); border-radius: 10px; padding: 10px; }
#histCanvas { width: 100%; height: 240px; }
#stats {
  position: absolute;
  top: 10px;
  right: 10px;
  width: 300px;          /* increased width */
  padding: 20px;         /* more padding */
  background: rgba(40,40,60,0.95);
  border-radius: 12px;
  text-align: left;
  color: #fff;
  font-size: 16px;       /* larger font */
  line-height: 1.6;
  box-shadow: 0 6px 20px rgba(0,0,0,0.5);
  z-index: 10;
}
#lastTrialBox { position: absolute; top: 200px; right: 10px; padding: 12px 16px; background: rgba(40,40,60,0.9); border-radius: 10px; text-align: left; min-width: 220px; color: #fff; font-size: 14px; max-width: 300px; word-wrap: break-word; }
.stickSpan { display: inline-block; margin: 2px 4px; padding: 2px 4px; border-radius: 4px; font-weight: normal; }
</style>
</head>
<body>

<h1>Uniform Sum Simulation for e</h1>

<div id="topDesc">
<strong>Process:</strong> Pick random numbers (0–1) end-to-end until they exceed the target. Count how many sticks were needed.
</div>

<div id="controls">
  <button id="dropStick">Drop One Stick</button>
  <button id="dropOneTrial">Run 1 Trial</button>
  <button id="drop10">Run 10</button>
  <button id="drop100">Run 100</button>
  <button id="drop1000">Run 1000</button>
  <label for="targetSumInput">Target sum:</label>
  <input type="number" id="targetSumInput" value="1" step="0.01" min="0.01">
</div>

<canvas id="stickCanvas" width="1000" height="220"></canvas>

<div id="histBox">
<canvas id="histCanvas" width="1000" height="240"></canvas>
</div>

<div id="stats"></div>
<div id="lastTrialBox"></div>

<div id="explanation">
<strong>Why it’s e:</strong> Consider picking numbers X₁, X₂, … uniformly from 0 to 1.<br>
To exceed a target sum of 1, there is only <strong>one ordering of n numbers</strong> that will first exceed the target exactly after the nth pick.  
The probability of that ordering is 1/n!, and summing these probabilities over n gives the series 1 + 1/1! + 1/2! + … = e.  
</div>

<script>
const stickCanvas = document.getElementById('stickCanvas');
const ctx = stickCanvas.getContext('2d');
const histCanvas = document.getElementById('histCanvas');
const histCtx = histCanvas.getContext('2d');
const statsDiv = document.getElementById('stats');
const lastTrialBox = document.getElementById('lastTrialBox');

let targetSum = parseFloat(document.getElementById('targetSumInput').value);
let currentSticks = [], currentSum = 0;
let trialResults = [], runningAverages = [];
let trialColors = [], animating = false;
let lastTrialSticks = [];

function makeColors(n=1000){
  let arr=[];
  for(let i=0;i<n;i++){arr.push(`hsl(${(i*137.5)%360},60%,60%)`);}
  return arr;
}
trialColors = makeColors();

function drawBase(){ const baseY=stickCanvas.height-40; ctx.strokeStyle="#aaa"; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(0,baseY); ctx.lineTo(stickCanvas.width,baseY); ctx.stroke(); return baseY; }

function drawStickSegment(x,width,y,index,val,isLast=false){
  const color = trialColors[index%trialColors.length];
  ctx.fillStyle=color; ctx.shadowColor=color; ctx.shadowBlur=12;
  ctx.fillRect(x,y,Math.max(2,width),28); ctx.shadowBlur=0;

  ctx.font='bold 14px Segoe UI'; ctx.textBaseline='middle';
  ctx.strokeStyle='rgba(0,0,0,0.8)'; ctx.lineWidth=4;

  ctx.textAlign = isLast ? 'left' : 'center';
  const cx = isLast ? x+2 : x+width/2;
  const cy = y+14;
  ctx.strokeText(val.toFixed(2), cx, cy); ctx.fillStyle='#fff';
  ctx.fillText(val.toFixed(2), cx, cy);
}

async function dropStickAnimated(len,index){
  const baseY=drawBase(), scale=stickCanvas.width/targetSum, stickWidth=len*scale;
  const x=currentSticks.slice(0,index).reduce((a,b)=>a+b,0)*scale;
  let y=-60;
  const isLast = currentSticks.reduce((a,b)=>a+b,0) + len > targetSum;
  return new Promise(resolve=>{
    function fall(){
      ctx.clearRect(0,0,stickCanvas.width,baseY);
      drawBase();
      let px=0;
      for(let i=0;i<index;i++){drawStickSegment(px,currentSticks[i]*scale,baseY-28,i,currentSticks[i]); px+=currentSticks[i]*scale;}
      if(y<baseY-28){ y+=20; drawStickSegment(x,stickWidth,y,index,len,isLast); requestAnimationFrame(fall); }
      else { drawStickSegment(x,stickWidth,baseY-28,index,len,isLast); resolve(); }
    } fall();
  });
}

function resetTrialState(){ currentSticks=[]; currentSum=0; drawBase(); }

function endTrial(){
  trialResults.push(currentSticks.length);
  lastTrialSticks = [...currentSticks]; // store last trial sticks
  let sum=0; 
  runningAverages = trialResults.map((v,i)=>{sum+=v; return sum/(i+1);});
  updateHistogram();
  updateStats();
  updateLastTrialBox();
}

function updateHistogram(){
  const freq={};
  for(let i=0;i<trialResults.length;i++){
    const v = trialResults[i];
    freq[v] = (freq[v]||0) + 1;
  }

  const maxVal = Math.max(Math.ceil(targetSum*4), ...trialResults, 10);
  const labels = Array.from({length:maxVal},(_,i)=>i+1);
  const data = labels.map(k=>freq[k]||0);

  histCtx.clearRect(0,0,histCanvas.width,histCanvas.height);
  const baseY = histCanvas.height-40;
  const barWidth = histCanvas.width/labels.length*0.8;

  for(let i=0;i<labels.length;i++){
    const h = (data[i]/Math.max(...data,1))*(histCanvas.height-60);
    let idx = trialResults.findIndex(v=>v===labels[i]);
    const color = idx>=0 ? trialColors[idx%trialColors.length] : '#666';
    histCtx.fillStyle=color;
    histCtx.fillRect(i*(histCanvas.width/labels.length)+barWidth*0.1,baseY-h,barWidth,h);
  }

  histCtx.fillStyle="#fff";
  histCtx.font='bold 14px Segoe UI';
  histCtx.textAlign='center';
  histCtx.textBaseline='top';
  for(let i=0;i<labels.length;i++){
    histCtx.fillText(labels[i], i*(histCanvas.width/labels.length)+barWidth/2, baseY+4);
  }
}

function updateStats(){
  if(trialResults.length===0){ statsDiv.innerHTML=''; return; }
  const n = trialResults.length;
  const avg = runningAverages[runningAverages.length-1];
  const variance = trialResults.reduce((a,b)=>a+Math.pow(b-avg,2),0)/n;
  const std = Math.sqrt(variance);
  let theoretical='';
  if(targetSum===1) theoretical = 'e ≈ 2.7183';
  else if(targetSum===2) theoretical = 'e²-e ≈ 4.6708';
  statsDiv.innerHTML=`<strong>Trials:</strong> ${n}<br><strong>Average sticks/trial:</strong> ${avg.toFixed(4)}<br><strong>Std deviation:</strong> ${std.toFixed(4)}<br><strong>Theoretical:</strong> ${theoretical}`;
}

function updateLastTrialBox(){
  if(lastTrialSticks.length===0){ lastTrialBox.innerHTML='No trial yet.'; return; }
  let sum=0;
  let content='';
  const scale=0.8; // max width scaling for wrap

  lastTrialSticks.forEach((v,i)=>{
    sum += v;
    const isLast = sum > targetSum;
    const color = trialColors[i%trialColors.length];
    content += `<span class="stickSpan" style="color:${color}; font-weight:${isLast?'bold':'normal'};">${v.toFixed(3)}</span> `;
  });
  lastTrialBox.innerHTML=`<strong>Last trial calculation:</strong><br>${content}<br>Sum = ${sum.toFixed(3)} &gt; ${targetSum}`;
}

// --- Button Actions ---
document.getElementById('dropStick').onclick = async () => {
  if (animating) return;

  if (currentSum >= targetSum) resetTrialState();

  animating = true;
  const len = Math.random();
  currentSticks.push(len);
  currentSum += len;

  await dropStickAnimated(len, currentSticks.length - 1);
  animating = false;

  if (currentSum > targetSum) endTrial();
};

document.getElementById('dropOneTrial').onclick = async ()=>{ if(!animating) {animating=true; await runSingleTrial(); animating=false;} };
document.getElementById('drop10').onclick = ()=>runTrials(10);
document.getElementById('drop100').onclick = ()=>runTrials(100);
document.getElementById('drop1000').onclick = ()=>runTrials(1000);

async function runSingleTrial(){
  resetTrialState();
  let s=0;
  while(s<=targetSum){ const len=Math.random(); currentSticks.push(len); await dropStickAnimated(len,currentSticks.length-1); s+=len; currentSum=s; }
  endTrial();
}

function runTrials(n){
  const newResults=[];
  for(let i=0;i<n;i++){let s=0,count=0; while(s<=targetSum){s+=Math.random(); count++;} newResults.push(count);}
  trialResults.push(...newResults); 
  lastTrialSticks = [...currentSticks]; // store last trial sticks for batch
  let sum=0; runningAverages = trialResults.map((v,i)=>{sum+=v; return sum/(i+1);});
  updateHistogram();
  updateStats();
  updateLastTrialBox();
}

document.getElementById('targetSumInput').onchange = (e)=>{
  targetSum=parseFloat(e.target.value);
  resetTrialState();
  trialResults=[];
  runningAverages=[];
  lastTrialSticks=[];
  updateHistogram();
  updateStats();
  updateLastTrialBox();
};

// Initialize
resetTrialState();
updateHistogram();
updateStats();
updateLastTrialBox();
</script>
</body>
</html>

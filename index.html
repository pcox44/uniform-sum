<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Uniform Sum Simulation</title>
<style>
body {
  font-family: 'Segoe UI', sans-serif;
  background: radial-gradient(circle at top left, #1a237e 0%, #311b92 100%);
  color: #eee;
  margin: 0;
  padding: 20px;
}
h1 { 
  margin: 0 0 12px 0; 
  color: #fff; 
  text-shadow: 2px 2px 6px rgba(0,0,0,0.8);
  text-align: center;
}
.container {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
  max-width: 1600px;
  margin: 0 auto;
}
#stickCanvas {
  width: 100%;
  height: 150px;
  background: rgba(20,20,40,0.9);
  display: block;
  border-radius: 10px;
  box-shadow: 0 8px 20px rgba(0,0,0,0.35);
  margin-bottom: 20px;
}
.left-panel { flex: 1 1 600px; min-width: 300px; }
.right-panel { flex: 1 1 350px; display: flex; flex-direction: column; gap: 20px; }

#topDesc, #controls, #histBox, #stats, #lastTrialBox {
  padding: 10px 16px;
  background: rgba(20,20,40,0.9);
  border-radius: 10px;
  line-height: 1.5;
  margin-bottom: 12px;
}

#controls {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  gap: 10px;
  background: rgba(25,25,60,0.85);
  padding: 12px 16px;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}

label {
  font-weight: bold;
  color: #b3e5fc;
  margin-left: 10px;
  font-size: 26px; 
  text-shadow: 0 0 8px rgba(0,255,255,0.8); 
}

input[type="number"] {
  background: rgba(10,10,30,0.9);
  border: 2px solid #26a69a;
  border-radius: 8px;
  padding: 8px 12px;
  color: #fff;
  font-size: 16px;
  width: 80px;
  transition: all 0.3s ease;
  outline: none;
  box-shadow: inset 0 0 6px rgba(0,255,255,0.2);
}
input[type="number"]:focus {
  border-color: #00e5ff;
  box-shadow: 0 0 10px rgba(0,255,255,0.7), inset 0 0 8px rgba(0,255,255,0.3);
}

button { 
  margin: 5px 5px 5px 0; 
  padding: 10px 20px; 
  font-size: 15px; 
  border: none; 
  border-radius: 8px; 
  cursor: pointer; 
  background: linear-gradient(135deg,#26a69a,#004d40); 
  color:white; 
  transition: all 0.2s ease;
}
button:hover { 
  background: linear-gradient(135deg,#4db6ac,#00695c); 
  box-shadow: 0 0 10px rgba(0,255,255,0.5);
  transform: scale(1.05);
}

canvas { display: block; margin: 8px 0; border-radius: 10px; }
#histCanvas { width: 100%; height: 240px; }

#stats, #lastTrialBox, .collapsible-content {
  padding: 20px;
  background: rgba(40,40,60,0.95);
  border-radius: 12px;
  color: #fff;
  font-size: 18px;
  line-height: 1.6;
  box-shadow: 0 6px 20px rgba(0,0,0,0.5);
  word-wrap: break-word;
}

.stickSpan { display: inline-block; margin: 2px 4px; padding: 2px 4px; border-radius: 4px; font-weight: normal; }

/* Histogram table */
#histTableContainer {
  background: rgba(20,20,40,0.9);
  padding: 10px 16px;
  border-radius: 10px;
  color: #fff;
  margin-bottom: 12px;
}

#histTableContainer table {
  width: 100%;
  border-collapse: collapse;
  font-size: 16px;
}
#histTableContainer th, #histTableContainer td {
  border-bottom: 1px solid rgba(255,255,255,0.2);
  padding: 6px 10px;
  text-align: left;
}
#histTableContainer th { color: #b3e5fc; font-weight: bold; }

/* Collapsible headers */
.collapsible {
  background: rgba(30,30,60,0.95);
  color: #fff;
  cursor: pointer;
  padding: 12px 16px;
  width: 100%;
  border: none;
  text-align: left;
  outline: none;
  font-size: 18px;
  border-radius: 10px;
  margin-bottom: 6px;
}
.collapsible:hover { background: rgba(50,50,80,0.95); }
.collapsible:after {
  content: '\25BC';
  float: right;
}
.collapsible.active:after {
  content: '\25B2';
}

.collapsible-content { display: none; }
</style>
</head>
<body>

<h1>Uniform Sum Simulation for e</h1>

<div id="topDesc">
  <strong>Process:</strong> Pick random numbers (0–1) end-to-end until they exceed the target. Count how many sticks were needed.
</div>

<canvas id="stickCanvas" width="1000" height="220"></canvas>

<div class="container">
  <div class="left-panel">
    <div id="controls">
      <button id="dropStick">Drop One Stick</button>
      <button id="dropOneTrial">Run 1 Trial</button>
      <button id="drop10">Run 10</button>
      <button id="drop1000">Run 1000</button>
      <button id="resetHist">Reset</button>
      <label for="targetSumInput">Target:</label>
      <input type="number" id="targetSumInput" value="1" step="0.01" min="0.01">
    </div>

    <div id="histBox">
      <canvas id="histCanvas" width="1000" height="240"></canvas>
    </div>

    <!-- Collapsible histogram table -->
    <button class="collapsible">Show/Hide Frequency Table</button>
    <div class="collapsible-content" id="histTableContainer"></div>
  </div>

  <div class="right-panel">
    <div id="stats"></div>
    <div id="lastTrialBox"></div>
  </div>
</div>

<!-- Collapsible explanation -->
<button class="collapsible">Show/Hide Explanation</button>
<div class="collapsible-content" id="explanation">
  <strong>Why it’s e:</strong>
  <p>
    Pick independent random numbers X₁, X₂, … from 0 to 1. Let N be the smallest number so that X₁ + … + X<sub>N</sub> exceeds the target.
  </p>
  <p>
    For a target of 1, the probability that the sum first exceeds 1 exactly on the nth number is 1/n!.  
    Therefore, the expected number of numbers needed is approximately e.
  </p>
</div>

<script>
// Collapsible toggle
document.querySelectorAll(".collapsible").forEach(btn => {
  btn.addEventListener("click", function() {
    this.classList.toggle("active");
    const content = this.nextElementSibling;
    if(content.style.display === "block") content.style.display = "none";
    else content.style.display = "block";
  });
});

// (JS for simulation: reuse all your existing JS for sticks, histogram, table, stats, etc.)
// --- Copy your previous JS here unchanged ---
const stickCanvas = document.getElementById('stickCanvas');
const ctx = stickCanvas.getContext('2d');
const histCanvas = document.getElementById('histCanvas');
const histCtx = histCanvas.getContext('2d');
const statsDiv = document.getElementById('stats');
const lastTrialBox = document.getElementById('lastTrialBox');

let targetSum = parseFloat(document.getElementById('targetSumInput').value);
let currentSticks = [], currentSum = 0;
let trialResults = [], lastStickIndices = [];
let dropOneActive = false; 

const firstNeonColors = [
  '#ff9800', '#00ff00', '#ff00ff', '#ff1744', '#00FFFF', 
  '#ff6d00', '#ffeb3b', '#FF8DA1', '#00ff00'
];

function getStickColor(index){if(index < firstNeonColors.length) return firstNeonColors[index]; return firstNeonColors[(index - firstNeonColors.length) % firstNeonColors.length];}

// ----- Updated drawBase() -----
function drawBase(){ 
  ctx.clearRect(0,0,stickCanvas.width,stickCanvas.height);
  const baseY = stickCanvas.height - 50; // slightly higher for taller sticks
  ctx.strokeStyle="#aaa"; 
  ctx.lineWidth=3; 
  ctx.beginPath(); 
  ctx.moveTo(0,baseY); 
  ctx.lineTo(stickCanvas.width,baseY); 
  ctx.stroke();

  const boxSize = 8;
  const checkerStartX = stickCanvas.width - 60; // wider checkerboard
  for(let y=0; y<stickCanvas.height; y+=boxSize){
    for(let x=checkerStartX; x<stickCanvas.width; x+=boxSize*2){
      ctx.fillStyle = (Math.floor(y/boxSize)%2===0) ? "#fff" : "#000";
      ctx.fillRect(x, y, boxSize, boxSize);
      ctx.fillStyle = (Math.floor(y/boxSize)%2===0) ? "#000" : "#fff";
      ctx.fillRect(x+boxSize, y, boxSize, boxSize);
    }
  }

  return baseY;
}

// ----- Updated drawStickSegment() -----
function drawStickSegment(x, width, y, index, val, isLast=false){
  const stickHeight = 50; // taller sticks
  const color = getStickColor(index);
  ctx.fillStyle = color;
  ctx.fillRect(x, y, width, stickHeight);
  ctx.lineWidth = 6;
  ctx.strokeStyle = 'black';
  ctx.strokeRect(x, y, width, stickHeight);

  // font size proportional to stick height
  const fontSize = Math.min(24, Math.max(14, stickHeight * 0.6));
  ctx.font = `bold ${fontSize}px Segoe UI`;
  ctx.textBaseline = 'middle';
  ctx.fillStyle = '#000';

  const cy = y + stickHeight / 2;
  const leftPadding = 20; // extra padding for last stick
  ctx.textAlign = isLast ? 'left' : 'center';
  ctx.fillText(val.toFixed(2), isLast ? x + leftPadding : x + width / 2, cy);
}


async function dropStickAnimated(len, index){
  const baseY = drawBase();
  const scale = stickCanvas.width / targetSum;
  const stickWidth = len * scale;
  const x = currentSticks.slice(0,index).reduce((a,b)=>a+b,0) * scale;

  // During animation, always center numbers
  let y = -60;
  return new Promise(resolve => {
    function fall(){
      drawBase();
      let px = 0;
      for(let i=0;i<index;i++){
        // always center during animation
        drawStickSegment(px, currentSticks[i]*scale, baseY-28, i, currentSticks[i], false);
        px += currentSticks[i]*scale;
      }

      if(y < baseY-28){
        y += 20;
        drawStickSegment(px, stickWidth, y, index, len, false); // false during fall
        requestAnimationFrame(fall);
      } else {
        // landed! determine if this is the stick that goes over target
        const totalBefore = currentSticks.slice(0,index).reduce((a,b)=>a+b,0);
        const goesOver = totalBefore + len > targetSum;
        drawStickSegment(px, stickWidth, baseY-28, index, len, goesOver);
        resolve();
      }
    } 
    fall();
  });
}


function resetTrialState(){ currentSticks=[]; currentSum=0; drawBase(); dropOneActive=false; }

function endTrial(){
  trialResults.push(currentSticks.length);
  lastStickIndices.push(currentSticks.length-1);
  dropOneActive=false;
  updateHistogram();
  updateStats();
  updateLastTrialBox();
}

/* --- NEW: HISTOGRAM TABLE --- */
function updateHistTable() {
  const container = document.getElementById("histTableContainer");

  if (trialResults.length === 0) {
    container.innerHTML = "";
    return;
  }

  const maxVal = Math.max(...trialResults);
  const labels = Array.from({length: maxVal}, (_, i) => i + 1);
  const total = trialResults.length;

  let runningSum = 0;

  let html = `<table>
      <tr>
        <th>Sticks</th>
        <th>Count</th>
        <th>Relative Frequency</th>
        <th>Running Sum</th>
      </tr>`;

  labels.forEach(l => {
    const count = trialResults.filter(v => v === l).length;
    const rel = count / total;
    const contribution = l * rel;
    runningSum += contribution;

    html += `
      <tr>
        <td>${l}</td>
        <td>${count}</td>
        <td>${rel.toFixed(4)}</td>
        <td>${runningSum.toFixed(4)}</td>
      </tr>`;
  });

  html += `</table>`;
  container.innerHTML = html;
}


function updateStats() {
  if(trialResults.length === 0) {
    statsDiv.innerHTML = '';
    return;
  }

  const n = trialResults.length;
  const avg = trialResults.reduce((a, b) => a + b, 0) / n;

  let html = `<strong>Trials:</strong> ${n}<br>`;
  html += `<strong>Average sticks/trial:</strong> ${avg.toFixed(4)}<br>`;

  if(targetSum === 1 || targetSum === 2) {
    let theoreticalValue, theoreticalText;

    if(targetSum === 1) {
      theoreticalValue = Math.E;
      theoreticalText = `e ≈ ${theoreticalValue.toFixed(4)}`;
    } else if(targetSum === 2) {
      theoreticalValue = Math.E**2 - Math.E;
      theoreticalText = `e² - e ≈ ${theoreticalValue.toFixed(4)}`;
    }

    html += `<strong>Theoretical:</strong> ${theoreticalText}<br>`;
    html += `<strong>|Simulation - Theoretical|:</strong> ${Math.abs(avg - theoreticalValue).toFixed(4)}<br>`;
  }

  statsDiv.innerHTML = html;
}

function updateLastTrialBox(){
  if(currentSticks.length===0){ 
    lastTrialBox.innerHTML='No trial yet.'; 
    return; 
  }
  let sum = 0;
  let content = '';
  currentSticks.forEach((v,i)=>{
    sum += v;
    const isLast = sum > targetSum;
    const color = getStickColor(i);
    content += `<span class="stickSpan" style="
      color:${color}; 
      font-weight: bold;
      padding:2px 4px;
      border-radius:2px;
      ${isLast ? `border: 2px solid ${color};` : ''}">${v.toFixed(3)}</span> `;
  });

  lastTrialBox.innerHTML = `<strong>Last trial calculation:</strong><br>${content}<br>
    <strong>Sum:</strong> ${sum.toFixed(3)} &gt; ${targetSum}
    <span style="margin-left:50px;"><strong>Sticks used:</strong> ${currentSticks.length}</span>`;
}

// ---------------------- Histogram ----------------------
function updateHistogram() {
  histCtx.clearRect(0,0,histCanvas.width,histCanvas.height);

  const topPadding = 40;
  const bottomPadding = 60;
  const leftPadding = 70;
  const rightPadding = 20;

  const plotWidth = histCanvas.width - leftPadding - rightPadding;
  const plotHeight = histCanvas.height - topPadding - bottomPadding;

  if(trialResults.length===0) {
    updateHistTable();
    return;
  }

  const maxVal = Math.max(...trialResults, 10);
  const labels = Array.from({length:maxVal},(_,i)=>i+1);

  const counts = labels.map(l => trialResults.filter(v => v === l).length);
  const proportions = counts.map(c => c / trialResults.length);
  const maxProp = Math.max(...proportions);
  const yMax = maxProp * 1.1;

  const barWidth = plotWidth / labels.length * 0.8;

  histCtx.strokeStyle = 'rgba(255,255,255,0.2)';
  histCtx.lineWidth = 1;
  histCtx.font = '14px Segoe UI';
  histCtx.fillStyle = '#fff';
  histCtx.textAlign = 'right';
  histCtx.textBaseline = 'middle';

  const ySteps = 5;
  for(let i = 0; i <= ySteps; i++) {
      const prop = (i / ySteps) * maxProp;
      const yPos = topPadding + plotHeight - (prop / yMax * plotHeight);

      histCtx.beginPath();
      histCtx.moveTo(leftPadding, yPos);
      histCtx.lineTo(histCanvas.width - rightPadding, yPos);
      histCtx.stroke();

      histCtx.fillText(prop.toFixed(2), leftPadding - 10, yPos);
  }

  histCtx.save();
  histCtx.translate(20, histCanvas.height / 2);
  histCtx.rotate(-Math.PI / 2);
  histCtx.textAlign = 'center';
  histCtx.textBaseline = 'middle';
  histCtx.fillStyle = '#fff';
  histCtx.font = '16px Segoe UI';
  histCtx.fillText('Proportion', 0, 0);
  histCtx.restore();

  labels.forEach((label,i)=>{
    const count = counts[i];
    const proportion = proportions[i];
    const h = proportion / yMax * plotHeight;
    const color = getStickColor(label-1);
    histCtx.fillStyle = color;
    histCtx.fillRect(leftPadding + i*(plotWidth/labels.length)+barWidth*0.1,
                     topPadding + plotHeight - h,
                     barWidth,
                     h);
    histCtx.fillStyle = '#fff';
    histCtx.textAlign = 'center';
    histCtx.textBaseline = 'top';
    histCtx.fillText(label, leftPadding + i*(plotWidth/labels.length)+barWidth/2, topPadding + plotHeight + 5);
  });

  histCtx.textAlign = 'center';
  histCtx.textBaseline = 'top';
  histCtx.fillText('Sticks Needed', leftPadding + plotWidth/2, histCanvas.height - bottomPadding + 20);

  updateHistTable(); // NEW
}

// ---------------------- Button Events ----------------------
document.getElementById('dropStick').onclick = async()=>{
  if(!dropOneActive){ resetTrialState(); dropOneActive=true; }
  const len=Math.random();
  currentSticks.push(len);
  currentSum += len;
  await dropStickAnimated(len,currentSticks.length-1);
  if(currentSum>targetSum) endTrial();
};

document.getElementById('dropOneTrial').onclick = async()=>{
  resetTrialState();
  let s=0;
  while(s<=targetSum){
    const len=Math.random();
    currentSticks.push(len);
    await dropStickAnimated(len,currentSticks.length-1);
    s+=len; currentSum=s;
  }
  endTrial();
};

document.getElementById('drop10').onclick = ()=>runTrials(10, false);
document.getElementById('drop1000').onclick = ()=>runTrials(1000, false);

document.getElementById('resetHist').onclick = ()=>{
  trialResults=[];
  updateHistogram();
  resetTrialState();
};

document.getElementById('targetSumInput').addEventListener('input', e=>{
  targetSum=parseFloat(e.target.value);
  trialResults=[]; 
  updateHistogram();
  resetTrialState();
});

function runTrials(n, reset=true){
  if(reset) resetTrialState();
  for(let t=0;t<n;t++){
    let s=0,count=0;
    while(s<=targetSum){s+=Math.random();count++;}
    trialResults.push(count);
    lastStickIndices.push(count-1);
  }
  updateHistogram();
  updateStats();
  if(reset) resetTrialState();
}

// ----- Fix canvas for high-DPI / sharp text -----
function fixCanvasDPI(canvas, ctx) {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.scale(dpr, dpr);
}

// Apply to both canvases
fixCanvasDPI(stickCanvas, ctx);
fixCanvasDPI(histCanvas, histCtx);

// Redraw everything after fixing DPI
drawBase();
updateHistogram();


drawBase();
updateHistogram();
</script>

</body>
</html>

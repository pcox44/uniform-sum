<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Uniform Sum Simulation for e</title>
<style>
body {
  font-family: 'Segoe UI', sans-serif;
  background: radial-gradient(circle at top left, #1a237e 0%, #311b92 100%);
  color: #eee;
  margin: 0;
  padding: 20px;
}

h1 { 
  margin: 0 0 12px 0; 
  color: #fff; 
  text-shadow: 2px 2px 6px rgba(0,0,0,0.8);
  text-align: center;
}

.container {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
  max-width: 1600px;
  margin: 0 auto;
}

#stickCanvas {
  width: 100%;
  height: 220px;
  background: rgba(20,20,40,0.9);
  display: block;
  border-radius: 10px;
  box-shadow: 0 8px 20px rgba(0,0,0,0.35);
  margin-bottom: 20px;
}

.left-panel { flex: 1 1 600px; min-width: 300px; }
.right-panel { flex: 1 1 350px; display: flex; flex-direction: column; gap: 20px; }

#topDesc, #explanation, #histBox {
  padding: 10px 16px;
  background: rgba(20,20,40,0.9);
  border-radius: 10px;
  line-height: 1.5;
  margin-bottom: 12px;
}

/* Updated Controls Section */
#controls {
  margin: 12px 0;
  text-align: left;
  background: rgba(25, 25, 60, 0.85);
  padding: 12px 16px;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  gap: 10px;
}

label {
  font-weight: bold;
  color: #b3e5fc;
  margin-left: 10px;
  font-size: 26px; /* increased from 16px */
  text-shadow: 0 0 8px rgba(0,255,255,0.8); /* stronger glow for readability */
}

input[type="number"] {
  background: rgba(10,10,30,0.9);
  border: 2px solid #26a69a;
  border-radius: 8px;
  padding: 8px 12px;
  color: #fff;
  font-size: 16px;
  width: 80px;
  transition: all 0.3s ease;
  outline: none;
  box-shadow: inset 0 0 6px rgba(0,255,255,0.2);
}

input[type="number"]:focus {
  border-color: #00e5ff;
  box-shadow: 0 0 10px rgba(0,255,255,0.7), inset 0 0 8px rgba(0,255,255,0.3);
}

/* Buttons */
button { 
  margin: 5px 5px 5px 0; 
  padding: 10px 20px; 
  font-size: 15px; 
  border: none; 
  border-radius: 8px; 
  cursor: pointer; 
  background: linear-gradient(135deg,#26a69a,#004d40); 
  color:white; 
  transition: all 0.2s ease;
}
button:hover { 
  background: linear-gradient(135deg,#4db6ac,#00695c); 
  box-shadow: 0 0 10px rgba(0,255,255,0.5);
  transform: scale(1.05);
}

canvas { display: block; margin: 8px 0; border-radius: 10px; }

#histCanvas { width: 100%; height: 240px; }

#stats, #lastTrialBox {
  padding: 30px;
  background: rgba(40,40,60,0.95);
  border-radius: 12px;
  color: #fff;
  font-size: 20px;
  line-height: 1.8;
  box-shadow: 0 6px 20px rgba(0,0,0,0.5);
  word-wrap: break-word;
}
#lastTrialBox { font-size: 18px; }

.stickSpan { display: inline-block; margin: 2px 4px; padding: 2px 4px; border-radius: 4px; font-weight: normal; }
</style>
</head>
<body>

<h1>Uniform Sum Simulation for e</h1>

<div id="topDesc">
  <strong>Process:</strong> Pick random numbers (0–1) end-to-end until they exceed the target. Count how many sticks were needed.
</div>

<canvas id="stickCanvas" width="1000" height="220"></canvas>

<div class="container">
  <div class="left-panel">
    <div id="controls">
      <button id="dropStick">Drop One Stick</button>
      <button id="dropOneTrial">Run 1 Trial</button>
      <button id="drop10">Run 10</button>
      <button id="drop100">Run 100</button>
      <button id="drop1000">Run 1000</button>
      <label for="targetSumInput">Target:</label>
      <input type="number" id="targetSumInput" value="1" step="0.01" min="0.01">
    </div>

    <div id="histBox">
      <canvas id="histCanvas" width="1000" height="240"></canvas>
    </div>
  </div>

  <div class="right-panel">
    <div id="stats"></div>
    <div id="lastTrialBox"></div>
  </div>
</div>

<div id="explanation">
  <strong>Why it’s e:</strong>
  <p>
    Pick independent random numbers X₁, X₂, … from 0 to 1. Let N be the smallest number so that X₁ + … + X<sub>N</sub> exceeds the target.
  </p>
  <p>
    For a target of 1, the probability that the sum first exceeds 1 exactly on the nth number is 1/n!.  
    Therefore, the expected number of numbers needed is approximately e.
  </p>
</div>

<script>
const stickCanvas = document.getElementById('stickCanvas');
const ctx = stickCanvas.getContext('2d');
const histCanvas = document.getElementById('histCanvas');
const histCtx = histCanvas.getContext('2d');
const statsDiv = document.getElementById('stats');
const lastTrialBox = document.getElementById('lastTrialBox');

let targetSum = parseFloat(document.getElementById('targetSumInput').value);
let currentSticks = [], currentSum = 0;
let trialResults = [], lastStickIndices = [];
let dropOneActive = false; 

// Fixed first 9 neon colors, 9th is neon green
const firstNeonColors = [
  '#ff9800', // orange
  '#00ff00', // lime green
  '#ff00ff', // neon purple
  '#ff1744', // neon red
  '#00FFFF', // neon blue
  '#ff6d00 ', // bright green
  '#ffeb3b', // yellow
  '#FF8DA1', // orange-red
  '#00ff00'  // neon green
];

function getStickColor(index){
  if(index < firstNeonColors.length) return firstNeonColors[index];
  return firstNeonColors[(index - firstNeonColors.length) % firstNeonColors.length];
}

function drawBase(){ 
  ctx.clearRect(0,0,stickCanvas.width,stickCanvas.height);
  const baseY = stickCanvas.height - 40;
  ctx.strokeStyle="#aaa"; 
  ctx.lineWidth=3; 
  ctx.beginPath(); 
  ctx.moveTo(0,baseY); 
  ctx.lineTo(stickCanvas.width,baseY); 
  ctx.stroke(); 

  // Checkerboard finish line
  const boxSize = 8;
  for(let y=0;y<stickCanvas.height;y+=boxSize){
    for(let x=stickCanvas.width-20;x<stickCanvas.width;x+=boxSize*2){
      ctx.fillStyle=(Math.floor(y/boxSize)%2===0)?"#fff":"#000";
      ctx.fillRect(x,y,boxSize,boxSize);
      ctx.fillStyle=(Math.floor(y/boxSize)%2===0)?"#000":"#fff";
      ctx.fillRect(x+boxSize,y,boxSize,boxSize);
    }
  }
  return baseY;
}

function drawStickSegment(x,width,y,index,val,isLast=false){
  const color = getStickColor(index);
  ctx.fillStyle=color;
  ctx.fillRect(x,y,width,28);

  ctx.lineWidth=6;
  ctx.strokeStyle='black';
  ctx.strokeRect(x,y,width,28);

  const fontSize = Math.min(16, Math.max(12, width*0.3 + 8));
  ctx.font=`bold ${fontSize}px Segoe UI`;
  ctx.textBaseline='middle';
  ctx.fillStyle='#000'; // black numbers
  ctx.textAlign=isLast?'left':'center';
  const cy = y+14;
  ctx.fillText(val.toFixed(2), isLast ? x+2 : x+width/2, cy);
}

async function dropStickAnimated(len,index){
  const baseY = drawBase();
  const scale = stickCanvas.width / targetSum;
  const stickWidth = len*scale;
  const x = currentSticks.slice(0,index).reduce((a,b)=>a+b,0)*scale;
  const isLast = currentSticks.reduce((a,b)=>a+b,0)+len > targetSum;
  let y = -60;
  return new Promise(resolve=>{
    function fall(){
      drawBase();
      let px=0;
      for(let i=0;i<index;i++){
        const lastCheck = currentSticks.slice(0,i+1).reduce((a,b)=>a+b,0) > targetSum;
        drawStickSegment(px, currentSticks[i]*scale, baseY-28, i, currentSticks[i], lastCheck);
        px += currentSticks[i]*scale;
      }
      if(y<baseY-28){ y+=20; drawStickSegment(px, stickWidth, y, index, len, isLast); requestAnimationFrame(fall);}
      else { drawStickSegment(px, stickWidth, baseY-28, index, len, isLast); resolve(); }
    } fall();
  });
}

function resetTrialState(){ currentSticks=[]; currentSum=0; drawBase(); dropOneActive=false; }

function endTrial(){
  trialResults.push(currentSticks.length);
  lastStickIndices.push(currentSticks.length-1);
  dropOneActive=false;
  updateHistogram();
  updateStats();
  updateLastTrialBox();
}

function updateHistogram(){
  histCtx.clearRect(0,0,histCanvas.width,histCanvas.height);
  const baseY = histCanvas.height-40;
  const maxVal = Math.max(...trialResults,10);
  const labels = Array.from({length:maxVal},(_,i)=>i+1);
  const barWidth = histCanvas.width / labels.length * 0.8;
  const maxCount = Math.max(...labels.map(l=>trialResults.filter(v=>v===l).length),1);

  labels.forEach((label,i)=>{
    const count = trialResults.filter(v=>v===label).length;
    const color = getStickColor(label-1);
    const h = count / maxCount * (histCanvas.height-60);
    histCtx.fillStyle=color;
    histCtx.fillRect(i*(histCanvas.width/labels.length)+barWidth*0.1, baseY-h, barWidth, h);

    histCtx.fillStyle="#fff";
    histCtx.font='bold 14px Segoe UI';
    histCtx.textAlign='center';
    histCtx.textBaseline='top';
    histCtx.fillText(label, i*(histCanvas.width/labels.length)+barWidth/2, baseY+4);
  });
}

function updateStats(){
  if(trialResults.length===0){ statsDiv.innerHTML=''; return; }
  const n = trialResults.length;
  const avg = trialResults.reduce((a,b)=>a+b,0)/n;
  let html = `<strong>Trials:</strong> ${n}<br><strong>Average sticks/trial:</strong> ${avg.toFixed(4)}<br>`;
  if(targetSum===1 || targetSum===2){
    const theoretical = targetSum===1?2.7183:4.6708;
    html += `<strong>Theoretical:</strong> ${theoretical}<br>`;
    html += `<strong>|Simulation - Theoretical|:</strong> ${Math.abs(avg-theoretical).toFixed(4)}`;
  }
  statsDiv.innerHTML=html;
}

function updateLastTrialBox(){
  if(currentSticks.length===0){ lastTrialBox.innerHTML='No trial yet.'; return; }
  let sum=0;
  let content='';
  currentSticks.forEach((v,i)=>{
    sum+=v;
    const isLast = sum>targetSum;
    const color = getStickColor(i);
    content += `<span class="stickSpan" style="color:${color}; font-weight:${isLast?'bold':'normal'};">${v.toFixed(3)}</span> `;
  });
  lastTrialBox.innerHTML=`<strong>Last trial calculation:</strong><br>${content}<br>Sum = ${sum.toFixed(3)} &gt; ${targetSum}`;
}

// BUTTONS
document.getElementById('dropStick').onclick = async()=>{
  if(!dropOneActive){ resetTrialState(); dropOneActive=true; }
  const len=Math.random();
  currentSticks.push(len);
  currentSum += len;
  await dropStickAnimated(len,currentSticks.length-1);
  if(currentSum>targetSum) endTrial();
};

document.getElementById('dropOneTrial').onclick = async()=>{
  resetTrialState();
  let s=0;
  while(s<=targetSum){
    const len=Math.random();
    currentSticks.push(len);
    await dropStickAnimated(len,currentSticks.length-1);
    s+=len; currentSum=s;
  }
  endTrial();
};

document.getElementById('drop10').onclick = ()=>runTrials(10);
document.getElementById('drop100').onclick = ()=>runTrials(100);
document.getElementById('drop1000').onclick = ()=>runTrials(1000);

function runTrials(n){
  for(let t=0;t<n;t++){
    let s=0,count=0;
    while(s<=targetSum){s+=Math.random();count++;}
    trialResults.push(count);
    lastStickIndices.push(count-1);
  }
  updateHistogram();
  updateStats();
  updateLastTrialBox();
}

document.getElementById('targetSumInput').onchange = e=>{
  targetSum=parseFloat(e.target.value);
  resetTrialState();
  trialResults=[];
  lastStickIndices=[];
  updateHistogram();
  updateStats();
  updateLastTrialBox();
};

// INIT
resetTrialState();
updateHistogram();
updateStats();
updateLastTrialBox();
</script>
</body>
</html>

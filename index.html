<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Uniform Sum Simulation</title>
<style>
body {
  font-family: 'Segoe UI', sans-serif;
  background: radial-gradient(circle at top left, #1a237e 0%, #311b92 100%);
  color: #eee;
  margin: 0;
  padding: 20px;
}

h1 { 
  margin: 0 0 12px 0; 
  color: #fff; 
  text-shadow: 2px 2px 6px rgba(0,0,0,0.8);
  text-align: center;
}

.container {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
  max-width: 1600px;
  margin: 0 auto;
}

#stickCanvas {
  width: 100%;
  height: 220px;
  background: rgba(20,20,40,0.9);
  display: block;
  border-radius: 10px;
  box-shadow: 0 8px 20px rgba(0,0,0,0.35);
  margin-bottom: 20px;
}

.left-panel { flex: 1 1 600px; min-width: 300px; }
.right-panel { flex: 1 1 350px; display: flex; flex-direction: column; gap: 20px; }

#topDesc, #explanation, #histBox {
  padding: 10px 16px;
  background: rgba(20,20,40,0.9);
  border-radius: 10px;
  line-height: 1.5;
  margin-bottom: 12px;
}

#controls {
  margin: 12px 0;
  text-align: left;
  background: rgba(25, 25, 60, 0.85);
  padding: 12px 16px;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  gap: 10px;
}

label {
  font-weight: bold;
  color: #b3e5fc;
  margin-left: 10px;
  font-size: 26px; 
  text-shadow: 0 0 8px rgba(0,255,255,0.8); 
}

input[type="number"] {
  background: rgba(10,10,30,0.9);
  border: 2px solid #26a69a;
  border-radius: 8px;
  padding: 8px 12px;
  color: #fff;
  font-size: 16px;
  width: 80px;
  transition: all 0.3s ease;
  outline: none;
  box-shadow: inset 0 0 6px rgba(0,255,255,0.2);
}

input[type="number"]:focus {
  border-color: #00e5ff;
  box-shadow: 0 0 10px rgba(0,255,255,0.7), inset 0 0 8px rgba(0,255,255,0.3);
}

button { 
  margin: 5px 5px 5px 0; 
  padding: 10px 20px; 
  font-size: 15px; 
  border: none; 
  border-radius: 8px; 
  cursor: pointer; 
  background: linear-gradient(135deg,#26a69a,#004d40); 
  color:white; 
  transition: all 0.2s ease;
}
button:hover { 
  background: linear-gradient(135deg,#4db6ac,#00695c); 
  box-shadow: 0 0 10px rgba(0,255,255,0.5);
  transform: scale(1.05);
}

canvas { display: block; margin: 8px 0; border-radius: 10px; }

#histCanvas { width: 100%; height: 240px; }

#stats, #lastTrialBox {
  padding: 20px;
  background: rgba(40,40,60,0.95);
  border-radius: 12px;
  color: #fff;
  font-size: 20px;
  line-height: 1.8;
  box-shadow: 0 6px 20px rgba(0,0,0,0.5);
  word-wrap: break-word;
}
#lastTrialBox { font-size: 18px; }

.stickSpan { display: inline-block; margin: 2px 4px; padding: 2px 4px; border-radius: 4px; font-weight: normal; }
</style>
</head>
<body>

<h1>Uniform Sum Simulation for e</h1>

<div id="topDesc">
  <strong>Process:</strong> Pick random numbers (0–1) end-to-end until they exceed the target. Count how many sticks were needed.
</div>

<canvas id="stickCanvas" width="1000" height="220"></canvas>

<div class="container">
  <div class="left-panel">
    <div id="controls">
      <button id="dropStick">Drop One Stick</button>
      <button id="dropOneTrial">Run 1 Trial</button>
      <button id="drop10">Run 10</button>
      <button id="drop1000">Run 1000</button>
      <button id="resetHist">Reset</button>
      <label for="targetSumInput">Target:</label>
      <input type="number" id="targetSumInput" value="1" step="0.01" min="0.01">
    </div>

    <div id="histBox">
      <canvas id="histCanvas" width="1000" height="240"></canvas>
    </div>
  </div>

  <div class="right-panel">
    <div id="stats"></div>
    <div id="lastTrialBox"></div>
  </div>
</div>

<div id="explanation">
  <strong>Why it’s e:</strong>
  <p>
    Pick independent random numbers X₁, X₂, … from 0 to 1. Let N be the smallest number so that X₁ + … + X<sub>N</sub> exceeds the target.
  </p>
  <p>
    For a target of 1, the probability that the sum first exceeds 1 exactly on the nth number is 1/n!.  
    Therefore, the expected number of numbers needed is approximately e.
  </p>
</div>

<script>
const stickCanvas = document.getElementById('stickCanvas');
const ctx = stickCanvas.getContext('2d');
const histCanvas = document.getElementById('histCanvas');
const histCtx = histCanvas.getContext('2d');
const statsDiv = document.getElementById('stats');
const lastTrialBox = document.getElementById('lastTrialBox');

let targetSum = parseFloat(document.getElementById('targetSumInput').value);
let currentSticks = [], currentSum = 0;
let trialResults = [], lastStickIndices = [];
let dropOneActive = false; 

const firstNeonColors = [
  '#ff9800', '#00ff00', '#ff00ff', '#ff1744', '#00FFFF', 
  '#ff6d00', '#ffeb3b', '#FF8DA1', '#00ff00'
];

function getStickColor(index){
  if(index < firstNeonColors.length) return firstNeonColors[index];
  return firstNeonColors[(index - firstNeonColors.length) % firstNeonColors.length];
}

function drawBase(){ 
  ctx.clearRect(0,0,stickCanvas.width,stickCanvas.height);
  const baseY = stickCanvas.height - 40;
  
  ctx.strokeStyle="#aaa"; 
  ctx.lineWidth=3; 
  ctx.beginPath(); 
  ctx.moveTo(0,baseY); 
  ctx.lineTo(stickCanvas.width,baseY); 
  ctx.stroke(); 

  const boxSize = 8;
  for(let y=0;y<stickCanvas.height;y+=boxSize){
    for(let x=stickCanvas.width-20;x<stickCanvas.width;x+=boxSize*2){
      ctx.fillStyle=(Math.floor(y/boxSize)%2===0)?"#fff":"#000";
      ctx.fillRect(x,y,boxSize,boxSize);
      ctx.fillStyle=(Math.floor(y/boxSize)%2===0)?"#000":"#fff";
      ctx.fillRect(x+boxSize,y,boxSize,boxSize);
    }
  }

  return baseY;
}

function drawStickSegment(x,width,y,index,val,isLast=false){
  const color = getStickColor(index);
  ctx.fillStyle=color;
  ctx.fillRect(x,y,width,28);
  ctx.lineWidth=6;
  ctx.strokeStyle='black';
  ctx.strokeRect(x,y,width,28);
  const fontSize = Math.min(16, Math.max(12, width*0.3 + 8));
  ctx.font=`bold ${fontSize}px Segoe UI`;
  ctx.textBaseline='middle';
  ctx.fillStyle='#000';
  ctx.textAlign=isLast?'left':'center';
  const cy = y+14;
  ctx.fillText(val.toFixed(2), isLast ? x+2 : x+width/2, cy);
}

async function dropStickAnimated(len,index){
  const baseY = drawBase();
  const scale = stickCanvas.width / targetSum;
  const stickWidth = len*scale;
  const x = currentSticks.slice(0,index).reduce((a,b)=>a+b,0)*scale;
  const isLast = currentSticks.reduce((a,b)=>a+b,0)+len > targetSum;
  let y = -60;
  return new Promise(resolve=>{
    function fall(){
      drawBase();
      let px=0;
      for(let i=0;i<index;i++){
        drawStickSegment(px, currentSticks[i]*scale, baseY-28, i, currentSticks[i]);
        px += currentSticks[i]*scale;
      }
      if(y<baseY-28){ y+=20; drawStickSegment(px, stickWidth, y, index, len, isLast); requestAnimationFrame(fall);}
      else { drawStickSegment(px, stickWidth, baseY-28, index, len, isLast); resolve(); }
    } fall();
  });
}

function resetTrialState(){ currentSticks=[]; currentSum=0; drawBase(); dropOneActive=false; }

function endTrial(){
  trialResults.push(currentSticks.length);
  lastStickIndices.push(currentSticks.length-1);
  dropOneActive=false;
  updateHistogram();
  updateStats();
  updateLastTrialBox();
}

function updateStats() {
  if(trialResults.length === 0) {
    statsDiv.innerHTML = '';
    return;
  }

  const n = trialResults.length;
  const avg = trialResults.reduce((a, b) => a + b, 0) / n;

  let html = `<strong>Trials:</strong> ${n}<br>`;
  html += `<strong>Average sticks/trial:</strong> ${avg.toFixed(4)}<br>`;

  if(targetSum === 1 || targetSum === 2) {
    let theoreticalValue, theoreticalText;

    if(targetSum === 1) {
      theoreticalValue = Math.E;
      theoreticalText = `e ≈ ${theoreticalValue.toFixed(4)}`;
    } else if(targetSum === 2) {
      theoreticalValue = Math.E**2 - Math.E;
      theoreticalText = `e² - e ≈ ${theoreticalValue.toFixed(4)}`;
    }

    html += `<strong>Theoretical:</strong> ${theoreticalText}<br>`;
    html += `<strong>|Simulation - Theoretical|:</strong> ${Math.abs(avg - theoreticalValue).toFixed(4)}<br>`;
  }

  statsDiv.innerHTML = html;
}



function updateLastTrialBox(){
  if(currentSticks.length===0){ 
    lastTrialBox.innerHTML='No trial yet.'; 
    return; 
  }
  let sum = 0;
  let content = '';
  currentSticks.forEach((v,i)=>{
    sum += v;
    const isLast = sum > targetSum;
    const color = getStickColor(i);
    content += `<span class="stickSpan" style="
      color:${color}; 
      font-weight: bold;
      padding:2px 4px;
      border-radius:2px;
      ${isLast ? `border: 2px solid ${color};` : ''}">${v.toFixed(3)}</span> `;
  });

  lastTrialBox.innerHTML = `<strong>Last trial calculation:</strong><br>${content}<br>
    <strong>Sum:</strong> ${sum.toFixed(3)} &gt; ${targetSum}
    <span style="margin-left:50px;"><strong>Sticks used:</strong> ${currentSticks.length}</span>`;
}

// ---------------------- Histogram ----------------------
function updateHistogram() {
  histCtx.clearRect(0,0,histCanvas.width,histCanvas.height);

  const topPadding = 40;
  const bottomPadding = 60;
  const leftPadding = 70;
  const rightPadding = 20;

  const plotWidth = histCanvas.width - leftPadding - rightPadding;
  const plotHeight = histCanvas.height - topPadding - bottomPadding;

  if(trialResults.length===0) return;

  const maxVal = Math.max(...trialResults, 10);
  const labels = Array.from({length:maxVal},(_,i)=>i+1);

  const counts = labels.map(l => trialResults.filter(v => v === l).length);
  const proportions = counts.map(c => c / trialResults.length);
  // New: 10% padding above the highest proportion
  const maxProp = Math.max(...proportions);
  const yMax = maxProp * 1.1;  // 10% higher than max

  const barWidth = plotWidth / labels.length * 0.8;

// Horizontal grid lines with proportion labels
histCtx.strokeStyle = 'rgba(255,255,255,0.2)';
histCtx.lineWidth = 1;
histCtx.font = '14px Segoe UI';
histCtx.fillStyle = '#fff';
histCtx.textAlign = 'right';
histCtx.textBaseline = 'middle';

const ySteps = 5; // number of horizontal lines
for(let i = 0; i <= ySteps; i++) {
    const prop = (i / ySteps) * maxProp; // actual proportion value
    const yPos = topPadding + plotHeight - (prop / yMax * plotHeight);

    // draw horizontal grid line
    histCtx.beginPath();
    histCtx.moveTo(leftPadding, yPos);
    histCtx.lineTo(histCanvas.width - rightPadding, yPos);
    histCtx.stroke();

    // draw proportion label
    histCtx.fillText(prop.toFixed(2), leftPadding - 10, yPos); // 10px left so visible
}

// Draw Y-axis label
histCtx.save();
histCtx.translate(20, histCanvas.height / 2); // move to left-middle
histCtx.rotate(-Math.PI / 2); // rotate vertical
histCtx.textAlign = 'center';
histCtx.textBaseline = 'middle';
histCtx.fillStyle = '#fff';
histCtx.font = '16px Segoe UI';
histCtx.fillText('Proportion', 0, 0);
histCtx.restore();


  // Bars
  labels.forEach((label,i)=>{
    const count = counts[i];
    const proportion = proportions[i];
    const h = proportion / yMax * plotHeight;
    const color = getStickColor(label-1);
    histCtx.fillStyle = color;
    histCtx.fillRect(leftPadding + i*(plotWidth/labels.length)+barWidth*0.1,
                     topPadding + plotHeight - h,
                     barWidth,
                     h);
    // x-axis stick number
    histCtx.fillStyle = '#fff';
    histCtx.textAlign = 'center';
    histCtx.textBaseline = 'top';
    histCtx.fillText(label, leftPadding + i*(plotWidth/labels.length)+barWidth/2, topPadding + plotHeight + 5);
  });

  histCtx.textAlign = 'center';
  histCtx.textBaseline = 'top';
  histCtx.fillText('Sticks Needed', leftPadding + plotWidth/2, histCanvas.height - bottomPadding + 20);
}

// ---------------------- Button Events ----------------------
document.getElementById('dropStick').onclick = async()=>{
  if(!dropOneActive){ resetTrialState(); dropOneActive=true; }
  const len=Math.random();
  currentSticks.push(len);
  currentSum += len;
  await dropStickAnimated(len,currentSticks.length-1);
  if(currentSum>targetSum) endTrial();
};

document.getElementById('dropOneTrial').onclick = async()=>{
  resetTrialState();
  let s=0;
  while(s<=targetSum){
    const len=Math.random();
    currentSticks.push(len);
    await dropStickAnimated(len,currentSticks.length-1);
    s+=len; currentSum=s;
  }
  endTrial();
};

// Additive trial buttons
document.getElementById('drop10').onclick = ()=>runTrials(10, false);
document.getElementById('drop1000').onclick = ()=>runTrials(1000, false);

// Reset button
document.getElementById('resetHist').onclick = ()=>{ trialResults=[]; updateHistogram(); resetTrialState(); };

document.getElementById('targetSumInput').addEventListener('input', e=>{
  targetSum=parseFloat(e.target.value);
  trialResults=[]; 
  updateHistogram();
  resetTrialState();
});

// Updated runTrials to optionally keep current sticks
function runTrials(n, reset=true){
  if(reset) resetTrialState();
  for(let t=0;t<n;t++){
    let s=0,count=0;
    while(s<=targetSum){s+=Math.random();count++;}
    trialResults.push(count);
    lastStickIndices.push(count-1);
  }
  updateHistogram();
  updateStats();
  if(reset) resetTrialState();
}

drawBase();
updateHistogram();


</script>

</body>

</html>

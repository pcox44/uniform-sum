<!DOCTYPE html>
<html lang="en">
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Uniform Sum Simulation</title>

<style>

/* Target input styling */
#targetSumInput {
  width: 80px;           /* make it wider */
  text-align: center;    /* center the number */
  font-size: 20px;       /* optional: make the number bigger */
  padding: 6px 10px;     /* slightly bigger padding */
  border-radius: 8px;
  border: 2px solid #26a69a;
  background: rgba(10,10,30,0.9);
  color: #fff;
  outline: none;
  box-shadow: inset 0 0 6px rgba(0,255,255,0.2);
}

/* Remove up/down arrow */
#targetSumInput::-webkit-inner-spin-button,
#targetSumInput::-webkit-outer-spin-button {
  -webkit-appearance: none;
  margin: 0;
}
#targetSumInput {
  -moz-appearance: textfield;
}

#topDesc {
  padding: 10px 16px;
  background: rgba(20,20,40,0.9);
  border-radius: 10px;
  line-height: 1.5;
  margin-bottom: 24px; /* increase spacing below */
}

#targetLabel {
  font-size: 36px;  /* make it bigger */
  font-weight: bold;
  color: #b3e5fc;
  text-shadow: 0 0 8px rgba(0,255,255,0.8);
}


#controls label[for="targetSumInput"] {
  font-size: 36px;   /* bigger */
  font-weight: bold;
}


#targetSumInput:focus {
  border-color: #00e5ff;
  box-shadow: 0 0 12px rgba(0,255,255,0.7), inset 0 0 8px rgba(0,255,255,0.3);
}


* { box-sizing: border-box; margin: 0; padding: 0; }

/* Histogram table styling */
#histTableContainer table {
  width: 100%;
  border-collapse: collapse;
  font-size: 16px;
  table-layout: auto;
}

#histTableContainer th, #histTableContainer td {
  border: 1px solid rgba(255,255,255,0.3);
  padding: 10px 14px;
  text-align: center;
}

#histTableContainer th {
  background: rgba(20, 60, 100, 0.8);
  color: #b3e5fc;
  font-weight: bold;
}

body {
  font-family: 'Segoe UI', sans-serif;
  background: radial-gradient(circle at top left, #1a237e 0%, #311b92 100%);
  color: #eee;
  padding: 20px;
}

/* remove the forced wide minimum (was causing layout troubles on phones) */
body {
  font-family: 'Segoe UI', sans-serif;
  background: radial-gradient(circle at top left, #1a237e 0%, #311b92 100%);
  color: #eee;
  padding: 20px;
  overflow-x: hidden;   /* avoid horizontal scroll on mobile */
}

/* container becomes fully fluid */
.container {
  display: flex;
  flex-wrap: nowrap;
  gap: 20px;
  max-width: 1600px;
  margin: 0 auto;
  width: 100%;
}

/* responsive panels */
.left-panel { flex: 0 0 67%; min-width: 260px; }
.right-panel { flex: 0 0 33%; min-width: 220px; }

/* Canvases scale with container width */
#stickCanvas, #histCanvas {
  width: 100%;         /* always full width of container */
  border-radius: 10px;
  display: block;
}

/* Desktop heights */
#stickCanvas { height: 120px; background: rgba(20,20,40,0.9); box-shadow: 0 8px 20px rgba(0,0,0,0.35); }
#histCanvas  { height: 300px; background: rgba(30,30,50,0.9); }

/* Mobile adjustments */
@media (max-width: 768px) {
  #stickCanvas { height: 120px; }
  #histCanvas  { height: 250px; }

  .container { flex-wrap: wrap; }
  .left-panel, .right-panel { flex: 1 1 100%; min-width: 0; }

  button { font-size: 12px; padding: 6px 10px; }
  label { font-size: 14px; }
}



/* Last trial & stats box */
#stats, #lastTrialBox {
  padding: 12px;
  background: rgba(30,30,60,0.95);
  border-radius: 10px;
  margin-bottom: 12px;
  font-size: 18px;
  overflow-x: auto; /* allow horizontal scroll if content is wide */
}

/* Mobile adjustments */
@media (max-width: 768px) {
  #stickCanvas { height: 120px; }
  #histCanvas  { height: 250px; }
}

#controls {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  align-items: center;
  background: rgba(25,25,60,0.85);
  padding: 12px;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
  margin-bottom: 12px;
}

/* Buttons styling */
button { 
  margin: 8px 6px 8px 0; 
  padding: 14px 28px;       /* bigger padding */
  font-size: 16px;          /* slightly larger text */
  border: none; 
  border-radius: 10px; 
  cursor: pointer; 
  background: linear-gradient(135deg,#26a69a,#004d40); 
  color:white; 
  transition: all 0.2s ease;
  min-width: 120px;          /* ensure wider clickable area */
}

button:hover { 
  background: linear-gradient(135deg,#4db6ac,#00695c); 
  box-shadow: 0 0 12px rgba(0,255,255,0.5);
  transform: scale(1.05);
}

label {
  color: #b3e5fc;
  font-weight: bold;
  font-size: 16px;
}

input[type="number"] {
  width: 60px;
  padding: 6px;
  font-size: 16px;
  border-radius: 6px;
  border: 2px solid #26a69a;
  background: rgba(10,10,30,0.9);
  color: #fff;
  text-align: center;
  outline: none;
}
input[type="number"]:focus { border-color: #00e5ff; box-shadow: 0 0 8px #00e5ff; }

#stats, #lastTrialBox, #histTableContainer, .collapsible-content {
  padding: 12px;
  background: rgba(30,30,60,0.95);
  border-radius: 10px;
  margin-bottom: 12px;
  font-size: 24px; /* desktop size */
  line-height: 1.5;
}

/* Mobile adjustments */
@media (max-width: 768px) {
  #stats, #lastTrialBox, #histTableContainer, .collapsible-content {
    font-size: 16px;  /* smaller for phones */
    padding: 10px;
  }
}

@media (max-width: 768px) {
  .collapsible {
    font-size: 18px;        /* slightly bigger for readability */
    padding: 16px 20px;     /* bigger touch area */
    display: inline-block;   /* size to fit text */
    min-width: 200px;        /* optional: prevent it from being too small */
    text-align: left;
  }
}


.stickSpan { display:inline-block; margin:2px 4px; padding:2px 4px; border-radius:3px; }

.collapsible {
  background: rgba(30,30,60,0.95);
  color: #fff;
  cursor: pointer;
  padding: 10px;
  border-radius: 10px;
  font-size: 16px;
  margin-bottom: 6px;
  width: 20%;
  text-align: left;
  border: none;
}
.collapsible:after { content: '\25BC'; float:right; }
.collapsible.active:after { content: '\25B2'; }
.collapsible-content { display:none; }

@media (max-width: 768px) {
  button { font-size: 12px; padding: 6px 10px; }
  label { font-size: 14px; }

  /* Let canvases shrink normally */
  #stickCanvas {
    width: 100%;
    height: auto;       /* remove forced zoom */
    min-height: 100px;  /* reasonable minimum */
  }
  
  #histCanvas {
    width: 100%;
    height: auto;       /* remove forced zoom */
    min-height: 150px;  /* reasonable minimum */
  }

  body {
    min-width: 0;
    overflow-x: hidden;
  }

  .container {
    flex-wrap: wrap;
  }

  .left-panel, .right-panel {
    flex: 1 1 100%;
    min-width: 0;
  }
}
.card {
  background: rgba(40,40,70,0.9);
  border-radius: 12px;
  padding: 12px 16px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
  margin-bottom: 12px;
}



</style>
</head>

<body>

<h1>Uniform Sum Simulation</h1>

<div id="topDesc" style="font-size: 18px; line-height: 1.6;">
  <strong>Process:</strong> 
  Generate independent random numbers from a uniform distribution on [0,1]. 
  Lay the ‚Äústicks‚Äù end-to-end, summing them, until the total exceeds the target. 
  Count how many sticks are needed.
</div>


<canvas id="stickCanvas"></canvas>

<div class="container">
  <div class="left-panel">
    <div id="controls">
      <button id="dropStick">Drop 1 Stick</button>
      <button id="dropOneTrial">Run 1 Trial</button>
      <button id="drop10">Run 10</button>
      <button id="drop1000">Run 1000</button>
      <button id="resetHist">Reset</button>
      <label for="targetSumInput">Target:</label>
      <input type="number" id="targetSumInput" value="1" step="0.01" min="0.01">
    </div>

    <canvas id="histCanvas"></canvas>
    <div id="histTableContainer"></div>
  </div>

  <div class="right-panel">
    <div id="stats"></div>
    <div id="lastTrialBox"></div>
  </div>
</div>

<button class="collapsible">
  \(\text{Explanation for Target = 1}\)
</button>

<div class="collapsible-content" style="font-size: 18px; line-height: 1.6; padding: 4px 2px;">

  <p>
  A classical result states
  \[
    \mathbb{P}(N = n) = \frac{1}{n!}.
  \]
  Therefore, the expected number of sticks is
  \[
    \mathbb{E}[N] = \sum_{n=1}^{\infty} n \cdot \frac{1}{n!}.
  \]
  Notice that
  \[
    \frac{n}{n!} = \frac{1}{(n-1)!},
  \]
  so we can rewrite the sum as
  \[
    \mathbb{E}[N] = \sum_{n=1}^{\infty} \frac{1}{(n-1)!} = \sum_{k=0}^{\infty} \frac{1}{k!} = e.
  \]
  Intuitively, this means it takes about \(e \approx 2.718\) sticks on average for the total to exceed 1, which matches what simulations show.
</p>


</div>




<script>
// Collapsible
document.querySelectorAll(".collapsible").forEach(btn=>{
  btn.addEventListener("click",function(){
    this.classList.toggle("active");
    const content=this.nextElementSibling;
    content.style.display=(content.style.display==='block')?'none':'block';
  });
});

// Core variables
const stickCanvas = document.getElementById('stickCanvas');
const ctx = stickCanvas.getContext('2d');
const histCanvas = document.getElementById('histCanvas');
const histCtx = histCanvas.getContext('2d');
const statsDiv = document.getElementById('stats');
const lastTrialBox = document.getElementById('lastTrialBox');

let targetSum = parseFloat(document.getElementById('targetSumInput').value);
let currentSticks = [], currentSum = 0;
let trialResults = [], lastStickIndices = [];
let dropOneActive = false;

const colors = ['#ff9800','#00ff00','#ff00ff','#ff1744','#00FFFF','#B57EDC','#ffeb3b','#FF8DA1','#0096FF'];

function getStickColor(i){ return colors[i%colors.length]; }

function fixCanvasDPI(canvas, ctx){
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.setTransform(1,0,0,1,0,0); // reset previous scaling
  ctx.scale(dpr, dpr);
}

window.addEventListener('resize', () => {
  fixCanvasDPI(stickCanvas, ctx);
  fixCanvasDPI(histCanvas, histCtx);
  drawBase();
  updateHistogram();
});


function cssSize(canvas) {
  // use clientWidth/clientHeight which represent CSS pixels
  return { w: canvas.clientWidth, h: canvas.clientHeight };
}

function drawBase() {
  // clear using device size then draw based on CSS sizes
  ctx.clearRect(0, 0, stickCanvas.width, stickCanvas.height);

  const { w: cW, h: cH } = cssSize(stickCanvas);
  const baseY = cH - 50;
  const overflowFraction = 0.10;
  const maxSum = Math.max(targetSum * (1 + overflowFraction), 0.001);
  const scale = cW / maxSum;   // pixels per unit (CSS pixels)

  // Draw baseline
  ctx.strokeStyle = "#aaa";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(0, baseY);
  ctx.lineTo(cW, baseY);
  ctx.stroke();

  // Draw checkerboard overflow region (use CSS coords)
  const checkerStartX = targetSum * scale;
  const checkerEndX = cW;
  const checkerHeight = cH;
  const boxSize = 8;

  for (let y = 0; y < checkerHeight; y += boxSize) {
    let toggle = Math.floor(y / boxSize) % 2 === 0;
    for (let x = checkerStartX; x < checkerEndX; x += boxSize) {
      ctx.fillStyle = toggle ? "#fff" : "#000";
      ctx.fillRect(x, y, boxSize, boxSize);
      toggle = !toggle;
    }
  }

  return baseY;
}

function drawStickSegment(xCss, widthCss, yCss, index, val, isLast=false) {
  const { w: cW, h: cH } = cssSize(stickCanvas);
  const stickHeight = cH * 0.50;
  const color = getStickColor(index);

  // draw using CSS pixel coordinates (ctx already scaled)
  ctx.fillStyle = color;
  ctx.fillRect(xCss, yCss, widthCss, stickHeight);

  ctx.lineWidth = 6;
  ctx.strokeStyle = 'black';
  ctx.strokeRect(xCss, yCss, widthCss, stickHeight);

  // font sizing using CSS pixels
  let baseFont = stickHeight * 0.8;
  let fontSize;
  const tinyThreshold = 0.045 * targetSum;

  if (val <= tinyThreshold) {
    const scaleFactor = val / tinyThreshold;
    fontSize = baseFont * 0.5 * scaleFactor;
    fontSize = Math.max(6, fontSize);
  } else {
    fontSize = baseFont * (targetSum > 1 ? 1 / Math.pow(targetSum, 0.25) : 1);
    fontSize = Math.min(38, fontSize);
  }

  // ------------------------------------------
  // üì± MOBILE LABEL SCALING (new)
  // ------------------------------------------
  if (window.innerWidth < 768) {
    fontSize *= 0.75;     // 45% smaller on mobile
  }
  // ------------------------------------------

  ctx.font = `bold ${fontSize}px Segoe UI`;
  ctx.textBaseline = 'middle';
  ctx.fillStyle = '#000';

  const cy = yCss + stickHeight / 2;

  // label position (center or shifted if last truncated)
  let textX = xCss + widthCss / 2;

  if (isLast) {
    const canvasRight = cW;
    const visibleWidth = Math.min(widthCss, canvasRight - xCss);
    const fractionVisible = visibleWidth / widthCss;
    const shiftThreshold = 0.6;
    if (fractionVisible < shiftThreshold) {
      textX = xCss + widthCss * fractionVisible / 2;
    } else {
      textX = xCss + widthCss / 2;
    }
  }

  ctx.textAlign = 'center';
  ctx.fillText(val.toFixed(2), textX, cy);
}



// Animated drop
async function dropStickAnimated(len, index) {
  const baseY = drawBase();
  const { w: cW } = cssSize(stickCanvas);
  const overflowFraction = 0.10;
  const maxSum = Math.max(targetSum * (1 + overflowFraction), 0.001);
  const scale = cW / maxSum;            // CSS pixels per unit
  const stickWidthCss = len * scale;

  // compute x in CSS pixels from sum of previous sticks (currentSticks holds raw numbers)
  const x = currentSticks.slice(0, index).reduce((a, b) => a + b, 0) * scale;

  let y = -60; // start above canvas (CSS px)
  return new Promise(resolve => {
    function fall() {
      drawBase();

      // draw previous sticks at final positions
      let px = 0;
      for (let i = 0; i < index; i++) {
        const wCss = currentSticks[i] * scale;
        drawStickSegment(px, wCss, baseY - 28, i, currentSticks[i], false);
        px += wCss;
      }

      if (y < baseY - 28) {
        y += 7;
        drawStickSegment(x, stickWidthCss, y, index, len, false);
        requestAnimationFrame(fall);
      } else {
        drawStickSegment(x, stickWidthCss, baseY - 28, index, len, true);
        resolve();
      }
    }
    fall();
  });
}

function resetTrialState(){ currentSticks=[]; currentSum=0; drawBase(); dropOneActive=false; }
function endTrial(){ trialResults.push(currentSticks.length); lastStickIndices.push(currentSticks.length-1); dropOneActive=false; updateHistogram(); updateStats(); updateLastTrialBox(); }

function fmt(x) {
  return parseFloat(x.toFixed(4)).toString();
}

// Update the "Last Trial" box
// Update the "Last Trial" box with 3 decimals for stick values
function updateLastTrialBox() {
  // clear if no sticks
  if (currentSticks.length === 0) {
    lastTrialBox.innerHTML = '';
    return;
  }

  let sum = 0;
  let content = '';
  currentSticks.forEach((v,i)=>{
    sum += v;
    const color = getStickColor(i);
    const isLast = sum > targetSum;

    content += `<span class="stickSpan" style="
      color:${color};
      ${isLast ? `border:2px solid ${color}; border-radius:4px; background: rgba(255,255,255,0.1); padding:2px 4px;` : ''}">
      ${v.toFixed(3)}
    </span> `;
  });

  lastTrialBox.innerHTML = `
    <div class="card">
      <strong>Last trial:</strong>
      <div style="margin:6px 0;">${content}</div>
      <div><strong>Sum:</strong> ${sum.toFixed(3)} > ${targetSum.toFixed(3)}</div>
      <div><strong>Sticks used:</strong> ${currentSticks.length}</div>
    </div>
  `;
}

// Update the "Stats" box
function updateStats() {
  if (trialResults.length === 0) {
    statsDiv.innerHTML = `
  <div class="card">
    <strong>Trials:</strong> ${n}<br>
    <strong>Average sticks:</strong> ${fmt(avg)}<br>
    ${theoretical}
  </div>
`;

    return;
  }

  const n = trialResults.length;
  const avg = trialResults.reduce((a, b) => a + b, 0) / n;

  // CSS style for math spans
  const mathStyle = 'font-size:0.9em; display:inline-block;';        // default
  const mathStyleSmall = 'font-size:0.8em; display:inline-block;';  // smaller for target 4

  let theoretical = '';

  if (targetSum === 1) {
    theoretical = `<strong>Theoretical:</strong> <span style="${mathStyle}">\\(e\\)</span> ‚âà ${fmt(Math.E)}<br>
                   <strong>|Sim - Theo|:</strong> ${fmt(Math.abs(avg - Math.E))}`;
  } else if (targetSum === 2) {
    const val = Math.E ** 2 - Math.E;
    theoretical = `<strong>Theoretical:</strong> <span style="${mathStyle}">\\(e^2 - e\\)</span> ‚âà ${fmt(val)}<br>
                   <strong>|Sim - Theo|:</strong> ${fmt(Math.abs(avg - val))}`;
  } else if (targetSum === 3) {
    const val = 0.5 * (2 * Math.E ** 3 - 4 * Math.E ** 2 + Math.E);
    theoretical = `<strong>Theoretical:</strong> <span style="${mathStyle}">\\(\\frac{1}{2}(2e^3 - 4e^2 + e)\\)</span> ‚âà ${fmt(val)}<br>
                   <strong>|Sim - Theo|:</strong> ${fmt(Math.abs(avg - val))}`;
  } else if (targetSum === 4) {
    const val = (1/6) * (6 * Math.E ** 4 - 18 * Math.E ** 3 + 12 * Math.E ** 2 - Math.E);
    theoretical = `<strong>Theoretical:</strong> <span style="${mathStyleSmall}">\\(\\frac{1}{6}(6e^4 - 18e^3 + 12e^2 - e)\\)</span> ‚âà ${fmt(val)}<br>
                   <strong>|Sim - Theo|:</strong> ${fmt(Math.abs(avg - val))}`;
  }

  statsDiv.innerHTML = `
    <div style="padding:12px; border-radius:10px; background: rgba(255,255,255,0.05);">
      <strong>Trials:</strong> ${n}<br>
      <strong>Average sticks:</strong> ${fmt(avg)}<br>
      ${theoretical}
    </div>
  `;

  // Render MathJax if loaded
  if (window.MathJax) MathJax.typesetPromise();
}



// --- Histogram Table ---
function updateHistTable() {
  const container = document.getElementById("histTableContainer");

  if (trialResults.length === 0) {
    container.innerHTML = "";
    return;
  }

  const maxVal = Math.max(...trialResults);
  const labels = Array.from({length: maxVal}, (_, i) => i + 1);
  const total = trialResults.length;

  let runningSum = 0;

  let html = `<table style="width:100%; border-collapse: collapse; text-align:center;">
      <tr>
        <th style="border:1px solid #fff; padding:6px;">Sticks</th>
        <th style="border:1px solid #fff; padding:6px;">Count</th>
        <th style="border:1px solid #fff; padding:6px;">Relative Frequency</th>
        <th style="border:1px solid #fff; padding:6px;">Running Sum</th>
      </tr>`;

  labels.forEach(l => {
    const count = trialResults.filter(v => v === l).length;

    // Skip rows with 0 count if targetSum > 4
    if (targetSum > 4 && count === 0) return;

    const rel = count / total;
    const contribution = l * rel;
    runningSum += contribution;

    html += `
      <tr>
        <td style="border:1px solid #fff; padding:6px;">${l}</td>
        <td style="border:1px solid #fff; padding:6px;">${count}</td>
        <td style="border:1px solid #fff; padding:6px;">${fmt(rel)}</td>
        <td style="border:1px solid #fff; padding:6px;">${fmt(runningSum)}</td>
      </tr>`;
  });

  html += `</table>`;
  container.innerHTML = html;
}

// --- Histogram Drawing ---
function updateHistogram() {
    const { w: cW, h: cH } = cssSize(histCanvas); // CSS pixels
    const topPadding = 40;
    const bottomPadding = 60;
    const leftPadding = 70;
    const rightPadding = 20;

    const plotWidth = cW - leftPadding - rightPadding;
    const plotHeight = cH - topPadding - bottomPadding;

    // clear background
    histCtx.fillStyle = 'rgb(30,30,50)';
    histCtx.fillRect(0, 0, cW, cH);

    if (trialResults.length === 0) {
        updateHistTable();
        return;
    }

    const rawMin = Math.min(...trialResults);
    const rawMax = Math.max(...trialResults);
    const target = Math.max(rawMax, 10);

    // x-axis minimum: shift 3 below rawMin only if target > 10
    const minVal = (target > 10) ? Math.max(1, rawMin - 9) : 1;

    // create labels from minVal to target
    const labels = Array.from({ length: target - minVal + 1 }, (_, i) => i + minVal);

    // counts and proportions
    const counts = labels.map(l => trialResults.filter(v => v === l).length);
    const proportions = counts.map(c => c / trialResults.length);
    const maxProp = Math.max(...proportions);
    const yMax = maxProp * 1.1;
    const barWidth = plotWidth / labels.length * 0.8;

    // draw horizontal grid lines
    histCtx.strokeStyle = 'rgba(255,255,255,0.2)';
    histCtx.lineWidth = 1;
    histCtx.font = '14px Segoe UI';
    histCtx.fillStyle = '#fff';
    histCtx.textAlign = 'right';
    histCtx.textBaseline = 'middle';
    const ySteps = 5;
    for (let i = 0; i <= ySteps; i++) {
        const prop = (i / ySteps) * maxProp;
        const yPos = topPadding + plotHeight - (prop / yMax * plotHeight);
        histCtx.beginPath();
        histCtx.moveTo(leftPadding, yPos);
        histCtx.lineTo(cW - rightPadding, yPos);
        histCtx.stroke();
        histCtx.fillText(prop.toFixed(2), leftPadding - 10, yPos);
    }

    // draw bars
    labels.forEach((label, i) => {
        const h = proportions[i] / yMax * plotHeight;
        const color = getStickColor(label - 1); // adjust if getStickColor expects 0-based index
        histCtx.fillStyle = color;
        histCtx.fillRect(
            leftPadding + i * (plotWidth / labels.length) + barWidth * 0.1,
            topPadding + plotHeight - h,
            barWidth,
            h
        );

        // x-axis numbers
        histCtx.fillStyle = '#fff';
        histCtx.textAlign = 'center';
        histCtx.textBaseline = 'top';
        histCtx.fillText(label, leftPadding + i * (plotWidth / labels.length) + barWidth / 2, topPadding + plotHeight + 5);
    });

    // x-axis label
    histCtx.textAlign = 'center';
    histCtx.textBaseline = 'top';
    histCtx.fillText('Sticks Needed', leftPadding + plotWidth / 2, cH - bottomPadding + 20);

    updateHistTable();
}




window.addEventListener('load', init);
window.addEventListener('resize', handleResize);


// --- Button events ---
document.getElementById('dropStick').onclick=async()=>{
  if(!dropOneActive) resetTrialState(), dropOneActive=true;
  const len=Math.random(); currentSticks.push(len); currentSum+=len;
  await dropStickAnimated(len,currentSticks.length-1);
  if(currentSum>targetSum) endTrial();
};
document.getElementById('dropOneTrial').onclick=async()=>{
  resetTrialState();
  let s=0;
  while(s<=targetSum){ const len=Math.random(); currentSticks.push(len); await dropStickAnimated(len,currentSticks.length-1); s+=len; currentSum=s; }
  endTrial();
};
document.getElementById('drop10').onclick=()=>runTrials(10,false);
document.getElementById('drop1000').onclick=()=>runTrials(1000,false);
document.getElementById('resetHist').onclick=()=>{ trialResults=[]; updateHistogram(); resetTrialState(); };
document.getElementById('targetSumInput').addEventListener('input',e=>{ targetSum=parseFloat(e.target.value); trialResults=[]; updateHistogram(); resetTrialState(); });

function runTrials(n,reset=true){ if(reset) resetTrialState();
  for(let t=0;t<n;t++){ let s=0,count=0; while(s<=targetSum){ s+=Math.random(); count++; } trialResults.push(count); lastStickIndices.push(count-1); }
  updateHistogram(); updateStats(); if(reset) resetTrialState();
}



function handleResize() {
  fixCanvasDPI(stickCanvas, ctx);
  fixCanvasDPI(histCanvas, histCtx);
  drawBase();
  updateHistogram();
}

function init() {
  // Wait for one animation frame to ensure layout has settled
  requestAnimationFrame(() => {
    handleResize();

    // Optional extra frame for really slow mobile rendering
    requestAnimationFrame(handleResize);
  });
}

window.addEventListener('load', init);
window.addEventListener('resize', handleResize);



</script>

</body>
</html>
